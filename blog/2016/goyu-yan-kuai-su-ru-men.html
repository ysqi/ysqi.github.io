<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Go语言快速入门 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。 最近决定深入地学习这门语言。 Hello World package main import &amp;quot;fmt&amp;quot; // this is a comment func main() { fmt.Println(&amp;quot;Hello World&amp;quot;) }"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/goyu-yan-kuai-su-ru-men.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="Go语言快速入门"><meta property="og:description" content="一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。 最近决定深入地学习这门语言。 Hello World package main import &quot;fmt&quot; // this is a comment func main() { fmt.Println(&quot;Hello World&quot;) }"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-kuai-su-ru-men.html"><meta property="article:published_time" content="2016-12-31T11:34:12&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:34:12&#43;08:00"><meta itemprop="name" content="Go语言快速入门"><meta itemprop="description" content="一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。 最近决定深入地学习这门语言。 Hello World package main import &quot;fmt&quot; // this is a comment func main() { fmt.Println(&quot;Hello World&quot;) }"><meta itemprop="datePublished" content="2016-12-31T11:34:12&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:34:12&#43;08:00"><meta itemprop="wordCount" content="3188"><meta itemprop="keywords" content="golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go语言快速入门"><meta name="twitter:description" content="一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。 最近决定深入地学习这门语言。 Hello World package main import &quot;fmt&quot; // this is a comment func main() { fmt.Println(&quot;Hello World&quot;) }"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Go语言快速入门</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 3188 字 </span><span class="more-meta">预计阅读 7 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><a href="#hello-world">Hello World</a></li><li><a href="#build-run">Build &amp; Run</a></li><li><a href="#executable-size">Executable Size</a></li><li><a href="#enviroment-variables">Enviroment Variables</a></li><li><a href="#workspace-hierarchy">Workspace Hierarchy</a></li><li><a href="#doc-server">Doc Server</a></li><li><a href="#basic-types">Basic Types</a><ul><li><ul><li><a href="#integer-numbers">Integer Numbers</a></li><li><a href="#booleans">Booleans</a></li><li><a href="#strings">Strings</a></li><li><a href="#enum">Enum</a></li></ul></li></ul></li><li><a href="#variables">Variables</a><ul><li><ul><li><a href="#scope">Scope</a></li><li><a href="#constants">Constants</a></li><li><a href="#defining-multiple-values">Defining Multiple Values</a></li></ul></li></ul></li><li><a href="#control-structures">Control Structures</a><ul><li><ul><li><a href="#if">IF</a></li><li><a href="#for">FOR</a></li><li><a href="#range">Range</a></li><li><a href="#switch">Switch</a></li></ul></li></ul></li><li><a href="#data-structures">Data Structures</a><ul><li><ul><li><a href="#array">Array</a></li><li><a href="#slice">Slice</a></li><li><a href="#map">Map</a></li><li><a href="#set">Set</a></li></ul></li></ul></li><li><a href="#functions">Functions</a><ul><li><ul><li><a href="#returning-multiple-values">Returning Multiple Values</a></li><li><a href="#variadic-functions">Variadic Functions</a></li><li><a href="#closure">Closure</a></li><li><a href="#recursion">Recursion</a></li><li><a href="#defer-panic-recover">Defer, Panic &amp; Recover</a></li><li><a href="#panic-recover">Panic &amp; Recover</a></li></ul></li></ul></li><li><a href="#pointers">Pointers</a><ul><li><ul><li><a href="#build-in-function-new">Build-in function “new”</a></li></ul></li></ul></li><li><a href="#structs">Structs</a><ul><li><ul><li><a href="#initialization">Initialization</a></li><li><a href="#constructor">Constructor?</a></li><li><a href="#methods">Methods</a></li><li><a href="#interfaces">Interfaces</a></li></ul></li></ul></li><li><a href="#packages">Packages</a><ul><li><ul><li><a href="#access-control">Access Control</a></li></ul></li></ul></li><li><a href="#concurrency">Concurrency</a><ul><li><ul><li><a href="#goroutines">Goroutines</a></li><li><a href="#channels">Channels</a></li></ul></li></ul></li><li><a href="#create-library">Create Library</a></li></ul></nav></div></div><div class="post-content"><p>一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。<br>最近决定深入地学习这门语言。</p><h1 id="hello-world">Hello World</h1><pre><code>package main

import &quot;fmt&quot;

// this is a comment

func main() {
    fmt.Println(&quot;Hello World&quot;)
}
</code></pre><h1 id="build-run">Build &amp; Run</h1><pre><code>$ cd D:\Go\src\github.com\sif\hello

$ go run main.go
Hello World

$ go build main.go

$ main.exe
Hello World

$ go clean
</code></pre><h1 id="executable-size">Executable Size</h1><p>Language</p><p>Executable Size (KB)</p><p>Comments</p><p>Go</p><p>1524</p><p>C++</p><p>12</p><p>Using cout. #include &lt;iostream&gt;</p><p>C++ (with runtime)</p><p>48</p><p>Using cout. #include &lt;iostream&gt;</p><p>C</p><p>7</p><p>Using printf() #include &lt;stdio.h&gt;</p><p>Go embeds the “virtual machine” into the executable.</p><h1 id="enviroment-variables">Enviroment Variables</h1><p>On 64bit Windows:</p><p>Name Value Comments</p><hr><p>GOARCH amd64<br>GOOS windows<br>GOPATH D:\Go Location of your workspaces. Can specify multiple workspaces. GOROOT C:\Go</p><p><strong>GOPATH</strong>可以指定多个workspaces。</p><h1 id="workspace-hierarchy">Workspace Hierarchy</h1><pre><code>bin\
    hello.exe

pkg\
    windows_amd64\
        carestream.com\dental\
            csi.a

src\
    github.com\sif\
        hello\
            hello.go
    carestream.com\dental\
        csi\
            patient.go
</code></pre><h1 id="doc-server">Doc Server</h1><p>Browse Go documents on <a href="http://localhost">http://localhost</a>:6060/</p><h1 id="basic-types">Basic Types</h1><h3 id="integer-numbers">Integer Numbers</h3><p><em>Integer types:</em><br><code>uint8, uint16, uint32, uint64, int8, int16, int32, int64</code></p><p><em>Two alias types:</em><br><code>byte (uint8) rune (int32)</code></p><p><em>Three machine dependent integer types:</em><br><code>uint, int, uintptr</code><br>They are machine dependent because their size depends on the type of architecture you are using.</p><p><em>Floating Point Numbers</em><br><code>float32, float64</code><br>Generally we should stick with float64 when working with floating point numbers.</p><p><em>Complex Numbers</em><br><code>complex64, complex128</code></p><p>Operators +, -, *, / and % are all the same as C.</p><h3 id="booleans">Booleans</h3><pre><code>func main() {
    fmt.Println(true &amp;&amp; true)
    fmt.Println(true &amp;&amp; false)
    fmt.Println(true || true)
    fmt.Println(true || false)
    fmt.Println(!true)
}
</code></pre><h3 id="strings">Strings</h3><p>Go strings are made up of individual bytes, usually one for each character.</p><pre><code>&quot;Hello \nWorld&quot;  // Similar to C/C++

`Hello
 World`  // Similar to Python “””

func main() {
    fmt.Println(len(&quot;Hello World&quot;))
    fmt.Println(&quot;Hello World&quot;[1])
    fmt.Println(&quot;Hello &quot; + &quot;World&quot;)
}
</code></pre><p>Characters from other languages like Chinese are represented by more than one byte.</p><pre><code>func main() {
    s := &quot;abc汉字&quot;

    for i := 0; i &lt; len(s); i++ { // byte
        fmt.Printf(&quot;%c,&quot;, s[i])
    }

    fmt.Println()
    for _, r := range s { // rune
        fmt.Printf(&quot;%c,&quot;, r)
    }
}
</code></pre><p>Output:</p><pre><code>a,b,c,æ,±,,å,,,
a,b,c,汉,字,
</code></pre><h3 id="enum">Enum</h3><pre><code>// A Month specifies a month of the year (January = 1, ...).
type Month int

const (
    January Month = 1 + iota
    February
    March
    April
    May
    // ...
    November
    December
)
</code></pre><h1 id="variables">Variables</h1><pre><code>func main() {
    var x string = &quot;Hello World&quot;
    fmt.Println(x)
}
</code></pre><p>Shorter form:</p><pre><code>x := &quot;Hello World&quot;
</code></pre><p>The type is not necessary because the Go compiler is able to infer the type based on the literal value you assign the variable.<br>The compiler can also do inference with the var statement:</p><pre><code>var x = &quot;Hello World&quot;
</code></pre><p>Generally you should use this shorter form whenever possible.</p><h3 id="scope">Scope</h3><p>The same as C.</p><h3 id="constants">Constants</h3><p>Constants are basically variables whose values cannot be changed later.</p><pre><code>func main() {
    const x string = &quot;Hello World&quot;
    fmt.Println(x)
}

const x string = &quot;Hello World&quot;
x = &quot;Some other string&quot;  // cannot assign to x
</code></pre><p>Constants must be numbers, strings and booleans which can be determined in compile time.</p><h3 id="defining-multiple-values">Defining Multiple Values</h3><pre><code>var (
    a = 5
    b = 10
    c = 15
)

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
</code></pre><h1 id="control-structures">Control Structures</h1><h3 id="if">IF</h3><p>可省略条件表达式括号。<br>支持初始化语句，可定义代码块局部变量。<br>代码块左大括号必须在条件表达式尾部。</p><pre><code>x := 0

if n := &quot;abc&quot;; x &gt; 0 {
    fmt.Println(n[2])
} else if x &lt; 0 {
    fmt.Println(n[1])
} else {
    fmt.Println(n[0])
}
</code></pre><p>但是，不支持三元操作符 &ldquo;a &gt; b ? a : b&rdquo;。</p><h3 id="for">FOR</h3><pre><code>s := &quot;abc&quot;

for i, n := 0, len(s); i &lt; n; i++ {    // 常见的 for 循环
    fmt.Println(s[i])
}

n := len(s)
for n &gt; 0 {                 // 替代 while (n &gt; 0) {}
    fmt.Println(s[n])             // 替代 for (; n &gt; 0;) {}
    n--
}

for {                         // 替代 while (true) {}
    fmt.Println(s)             // 替代 for (;;) {}
}
</code></pre><h3 id="range">Range</h3><p>类似迭代器操作，返回（索引，值）或（键，值）。</p><pre><code>            1st value   2nd value    
</code></pre><hr><p>string index s[index] unicode, rune array/slice index s[index]<br>map key m[key]<br>channel element</p><pre><code>s := &quot;abc&quot;

// 忽略 2nd value，支持 string/array/slice/map。
for i := range s {
    fmt.Println(s[i])
}

for _, c := range s {     // 忽略 index
    fmt.Println(c)
}

m := map[string]int{&quot;a&quot;: 1, &quot;b&quot;: 2}
for k, v := range m {     // 返回 (key, value)
    fmt.Println(k, v)
}
</code></pre><h3 id="switch">Switch</h3><p>分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。</p><pre><code>x := []int{1, 2, 3}
i := 2

switch i {
case x[1]:        // 不限于常量
    fmt.Println(&quot;a&quot;)
case 1, 3:        // 多值匹配
    fmt.Println(&quot;b&quot;)
 default:
    fmt.Println(&quot;c&quot;)
}
</code></pre><p>如需要继续下一分支，可使用 fallthrough，但不再判断条件。</p><pre><code>x := 10

switch x {
case 10:
    fmt.Println(&quot;a&quot;)
    fallthrough
case 0:
    fmt.Println(&quot;b&quot;)
}
</code></pre><p>Output:</p><pre><code>a
b
</code></pre><p>省略条件表达式，可当 if&hellip;else if&hellip;else 使用。</p><pre><code>switch {
case x[1] &gt; 0:
    fmt.Println(&quot;a&quot;)
case x[1] &lt; 0:
    fmt.Println(&quot;b&quot;)
default:
    fmt.Println(&quot;c&quot;)
}

switch i := x[2]; { // 带初始化语句
case i &gt; 0:
    fmt.Println(&quot;a&quot;)
case i &lt; 0:
    fmt.Println(&quot;b&quot;)
default:
    fmt.Println(&quot;c&quot;)
}
</code></pre><h1 id="data-structures">Data Structures</h1><h3 id="array">Array</h3><pre><code>var a [4]int
fmt.Println(a)              // [0 0 0 0]
fmt.Println(len(a))          // 4
fmt.Println(cap(a))          // 4

var a = [2]string{&quot;Penn&quot;, &quot;Teller&quot;}
fmt.Println(a)              // [Penn Teller]
fmt.Println(len(a))          // 2

var a = [...]string{&quot;Penn&quot;, &quot;Teller&quot;}
fmt.Println(a)              // [Penn Teller]
fmt.Println(len(a))          // 2
</code></pre><p><strong>Similar to C but with differencies:</strong><br>Go&rsquo;s arrays are values. An array variable denotes the entire array; it is not a pointer to the first array element (as would be the case in C).</p><h3 id="slice">Slice</h3><p>The type specification for a slice:</p><pre><code>[]T
</code></pre><p>Slices build on arrays to provide great power and convenience. Unlike an array type, a slice type has no specified length.<br>Create with literal:</p><pre><code>var s = []int{0, 1, 2, 3, 4}
fmt.Println(s)              // [0 1 2 3 4]
fmt.Println(len(s))         // 5
fmt.Println(cap(s))         // 5
</code></pre><p>Create with built-in function make:</p><pre><code>func make([]T, len, cap) []T

var s = make([]int, 5, 10)
fmt.Println(s)              // [0 0 0 0 0]
fmt.Println(len(s))         // 5
fmt.Println(cap(s))         // 10
</code></pre><p>The zero value of a slice is nil.</p><pre><code>var s []int
fmt.Println(s)             // []
fmt.Println(s == nil)      // true
fmt.Println(len(s))        // 0
</code></pre><p>Create by &ldquo;slicing&rdquo; an existing slice or array.</p><pre><code>b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}
// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
</code></pre><p>Create a slice given an array:</p><pre><code>b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
s := b[:]  // a slice referencing the storage of b
</code></pre><p>make([]byte, 5), is structured like this:</p><p>Re-slicing a slice doesn&rsquo;t make a copy of the underlying array.</p><pre><code>t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre><p>Grow a slice by built-in function append:</p><pre><code>func append(s []T, x ...T) []T 

a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre><p>Append one slice to another:</p><pre><code>a := []string{&quot;John&quot;, &quot;Paul&quot;}
b := []string{&quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
a = append(a, b...) // equivalent to &quot;append(a, b[0], b[1], b[2])&quot;
// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
</code></pre><h3 id="map">Map</h3><p>A map is an unordered collection of key-value pairs.</p><pre><code>var x map[string]int
</code></pre><p>x is a map of strings to ints.</p><p>Maps have to be initialized before they can be used.\</p><pre><code>x := make(map[string]int)
x[&quot;10&quot;] = 10
fmt.Println(x[&quot;10&quot;])
</code></pre><p>Delete items from a map using the built-in delete function:</p><pre><code>delete(x, “10”)
</code></pre><p>Looking up a key which doesn&rsquo;t exist returns the zero value.</p><pre><code>fmt.Println(x[&quot;unexisted&quot;])  // 0
</code></pre><p>Similar to C++ std::map.<br>Accessing an element of a map can return two values instead of just one.</p><p>The first value is the result of the lookup,<br>The second tells us whether or not the lookup was successful.</p><p>In Go we often see code like this:</p><pre><code>if value, ok := x[&quot;0&quot;]; ok {
    fmt.Println(value, ok)
}
</code></pre><p>Shorter way to create maps:</p><pre><code>x := map[string]int{
    &quot;1&quot;: 1,
    &quot;2&quot;: 2,
    &quot;3&quot;: 3,
}
</code></pre><h3 id="set">Set</h3><p>No build-in support.</p><pre><code>map[X]struct{}
</code></pre><h1 id="functions">Functions</h1><pre><code>func main() {
    xs := []float64{98, 93, 77, 82, 83}
    fmt.Println(average(xs))
}

func average(xs []float64) float64 {
    total := 0.0
    for _, v := range xs {
        total += v
    }
    return total / float64(len(xs))
}
</code></pre><p>We can also name the return type:</p><pre><code>func average(xs []float64) (avg float64) {
    total := 0.0
    for _, v := range xs {
        total += v
    }
    avg = total / float64(len(xs))
    return
}
</code></pre><h3 id="returning-multiple-values">Returning Multiple Values</h3><pre><code>func f() (int, int) {
    return 5, 6
}

func main() {
    x, y := f()
}
</code></pre><p>Multiple values are often used to return an error value along with the result, or a boolean to indicate success.<br>Here is a simple example, opening a file and reading some of it.</p><pre><code>file, err := os.Open(&quot;file.go&quot;)  // For read access.
if err != nil {
    log.Fatal(err)
}

count, err := file.Read(data)
if err != nil {
    log.Fatal(err)
}
</code></pre><p>Here&rsquo;s the implementation of method Read:</p><pre><code>// Read reads up to len(b) bytes from the File.
// It returns the number of bytes read and an error, if any.
// EOF is signaled by a zero count with err set to io.EOF.
func (f *File) Read(b []byte) (n int, err error) {
    if f == nil {
        return 0, ErrInvalid
    }
    n, e := f.read(b)
    if n &lt; 0 {
        n = 0
    }
    if n == 0 &amp;&amp; len(b) &gt; 0 &amp;&amp; e == nil {
        return 0, io.EOF
    }
    if e != nil {
        err = &amp;PathError{&quot;read&quot;, f.name, e}
    }
    return n, err
}
</code></pre><h3 id="variadic-functions">Variadic Functions</h3><p>There is a special form available for the last parameter in a Go function:</p><pre><code>func add(args ...int) int {  // Zero or more
    total := 0
    for _, v := range args {
        total += v
    }
    return total
}

func main() {
    fmt.Println(add(1,2,3))
}
</code></pre><p>This is precisely how the fmt.Println function is implemented:</p><pre><code>func Println(a ...interface{}) (n int, err error)
</code></pre><p>We can also pass a slice of ints by following the slice with &hellip;:</p><pre><code>func main() {
    xs := []int{1,2,3}
    fmt.Println(add(xs...))
}
</code></pre><h3 id="closure">Closure</h3><p>It is possible to create functions inside of functions:</p><pre><code>func main() {
    add := func(x, y int) int {
        return x + y
    }
    fmt.Println(add(1,1))
}
</code></pre><p>It also has access to other local variables:</p><pre><code>func main() {
    x := 0
    increment := func() int {
        x++
        return x
    }
    fmt.Println(increment())  // 1
    fmt.Println(increment())  // 2
}
</code></pre><p>A function like this together with the non-local variables it references is known as a closure.</p><h3 id="recursion">Recursion</h3><pre><code>func factorial(x uint) uint {
    if x == 0 {
        return 1
    }
    return x * factorial(x-1)
}
</code></pre><h3 id="defer-panic-recover">Defer, Panic &amp; Recover</h3><pre><code>func first() {
    fmt.Println(&quot;1st&quot;)
}
func second() {
    fmt.Println(&quot;2nd&quot;)
}
func main() {
    defer second()
    first()
}
</code></pre><p>Defer is often used when resources need to be freed in some way.</p><pre><code>f, _ := os.Open(filename)
defer f.Close()
</code></pre><h3 id="panic-recover">Panic &amp; Recover</h3><pre><code>func main() {
    defer func() {
        str := recover()
        fmt.Println(str)  // PANIC
    }()
    panic(&quot;PANIC&quot;)
}
</code></pre><p>A panic generally indicates a programmer error (for example,</p><p>attempting to access an index of an array that&rsquo;s out of bounds<br>forgetting to initialize a map<br>etc.</p><p>) or an exceptional condition that there&rsquo;s no easy way to recover from.</p><pre><code>// pkg\bytes\buffer.go

// makeSlice allocates a slice of size n. If the allocation fails,
// it panics with ErrTooLarge.
func makeSlice(n int) []byte {
    // If the make fails, give a known error.
    defer func() {
        if recover() != nil {
            panic(ErrTooLarge)
        }
    }()
    return make([]byte, n)
}
</code></pre><h1 id="pointers">Pointers</h1><p>Go is similar to C in pointers.</p><pre><code>func zero(xPtr *int) {  // pointer
    *xPtr = 0  // dereference
}

func main() {
    x := 5
    zero(&amp;x)  // address
    fmt.Println(x)  // 0
}
</code></pre><h3 id="build-in-function-new">Build-in function “new”</h3><p>Function “new” takes a type as an argument, allocates enough memory to fit a value of that type and returns a pointer to it.</p><pre><code>func one(xPtr *int) {
    *xPtr = 1
}

func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr)  // 1
}
</code></pre><p>Pointers are rarely used with Go&rsquo;s built-in types. They are extremely useful when paired with structs.</p><h1 id="structs">Structs</h1><p>A struct is a type which contains named fields.</p><pre><code>type Circle struct {
    x float64
    y float64
    r float64
}
</code></pre><p>The fields with the same type can be collapsed:</p><pre><code>type Circle struct {
    x, y, r float64
}
</code></pre><h3 id="initialization">Initialization</h3><p>Create a local variable with zero initialization:</p><pre><code>var c Circle  // {0 0 0}
</code></pre><p>Use new function:</p><pre><code>c := new(Circle)  // Also {0 0 0}
</code></pre><p>This allocates memory for all the fields, sets each of them to their zero value and returns a pointer (*Circle).<br>More often we want to give each of the fields a value.</p><pre><code>c := Circle{x: 0, y: 0, r: 5}
</code></pre><p>Or,</p><pre><code>c := Circle{0, 0, 5}
</code></pre><p>Note that variable c is NOT a pointer of Circle.</p><pre><code>func zeroCircle(c *Circle) {
    c.x = 0  // No -&gt; operator like C! Just use dot.
    c.y = 0
    c.r = 0
}

func main() {
    c := Circle{x: 0, y: 0, r: 5}
    zeroCircle(&amp;c)  // c is not a pointer, have to address it.
    fmt.Println(c)  // {0 0 0}
}
</code></pre><h3 id="constructor">Constructor?</h3><p>没有构造和析构方法，通常用简单工厂模式返回对象实例。</p><pre><code>type Queue struct {
    elements []interface{}
}
func NewQueue() *Queue {
    return &amp;Queue{make([]interface{}, 10)}
}

// src\pkg\container\list\list.go

package list

// New returns an initialized list.
func New() *List { return new(List).Init() }
</code></pre><h3 id="methods">Methods</h3><p>Normal function:</p><pre><code>func circleArea(c *Circle) float64 {
    return math.Pi * c.r*c.r
}
</code></pre><p>Method:</p><pre><code>func (c *Circle) area() float64 {  // Receiver
    return math.Pi * c.r*c.r
}
</code></pre><p>Call the method:</p><pre><code>fmt.Println(c.area())
</code></pre><h3 id="interfaces">Interfaces</h3><p>Similarily, define struct Rectangle:</p><pre><code>type Rectangle struct {
    x1, y1, x2, y2 float64
}

func (r *Rectangle) area() float64 {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    return l * w
}
</code></pre><p>Both Circle and Rectangle have a method named area(). Let&rsquo;s define an Interface for this similarity:</p><pre><code>type Shape interface {
    area() float64
}
</code></pre><p>Instead of defining fields, interface defines a “method set”: a list of methods that a type must have in order to “implement” the interface.<br>Function taking interface types as arguments:</p><pre><code>func totalArea(shapes ...Shape) float64 {
    var area float64
    for _, s := range shapes {
        area += s.area()
    }
    return area
}
</code></pre><p>Now call it:</p><pre><code>fmt.Println(totalArea(&amp;c, &amp;r))
</code></pre><p>Interfaces can also be used as fields:</p><pre><code>type MultiShape struct {
    shapes []Shape
}
</code></pre><p>We can even turn MultiShape itself into a Shape by giving it an area method:</p><pre><code>func (m *MultiShape) area() float64 {
    var area float64
    for _, s := range m.shapes {
        area += s.area()
    }
    return area
}
</code></pre><h1 id="packages">Packages</h1><p>编译工具对源码目录有严格要求，每个工作空间 (workspace) 必须由 bin、pkg、src 三个目录组成。</p><p>“D:\proj\Go” is NOT in \$GOPATH.</p><pre><code>$ D:\proj\Go&gt;go build hello.go

$ D:\proj\Go&gt;go install
go install: no install location for directory D:\proj\Go outside GOPATH
</code></pre><p><strong>所有代码都必须组织在 package 中：</strong><br>源文件头部以 &ldquo;package &lt;name&gt;&rdquo; 声明包名称。<br>包由同一目录下的多个源码文件组成。<br>包名类似 namespace，与包所在目录名、编译文件名无关。<br>可执行文件必须包含 package main，入口函数 main。</p><h3 id="access-control">Access Control</h3><p>Lower case private, upper case public.</p><pre><code>package list

type Element struct {
    next, prev *Element  // private
    list *List           // private
    Value interface{}    // public
}

package csi

type Patient struct {
    Id string
    Name string
    BirthDate time.Time
    dose float32            // Won't exported.
}

package main
...
p := &amp;csi.Patient{&quot;1&quot;, &quot;Adam&quot;, newDate(1984, time.March, 26), 1.0}

Error:
&gt; implicit assignment of unexported field 'dose' in csi.Patient literal
</code></pre><h1 id="concurrency">Concurrency</h1><p>Go has rich support for concurrency using goroutines and channels.</p><h3 id="goroutines">Goroutines</h3><p>A goroutine is a function that is capable of running concurrently with other functions.</p><pre><code>func f(n int) {
    for i := 0; i &lt; 10; i++ {
        fmt.Println(n, &quot;:&quot;, i)
    }
}

func main() {
    go f(0)
    var input string
    fmt.Scanln(&amp;input)
}
</code></pre><p>Goroutines are lightweight, you can create many of them:</p><pre><code>func main() {
    for i := 0; i &lt; 10; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&amp;input)
}
</code></pre><h3 id="channels">Channels</h3><p>Channels provide a way for two goroutines to communicate with one another and synchronize their execution.</p><pre><code>func pinger(c chan string) {
    for i := 0; ; i++ {
        c &lt;- &quot;ping&quot;
    }
}

func printer(c chan string) {
    for {
        msg := &lt;- c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}

func main() {
    var c chan string = make(chan string)
    go pinger(c)
    go printer(c)
    var input string
    fmt.Scanln(&amp;input)
}
</code></pre><p>When pinger attempts to send a message on the channel it will wait until printer is ready to receive the message. (this is known as blocking)</p><h1 id="create-library">Create Library</h1><p>Choose a package path (carestream.com/dental/csi) and create the package dir:</p><pre><code>  $GOPATH\src\carestream.com\dental\csi
</code></pre><p>Next, create a file named patient.go, containing the following code.</p><pre><code>package csi

import &quot;time&quot;

type Patient struct {
    Id string
    Name string
    BirthDate time.Time
    Dose float32
}
</code></pre><p>Now, build it:</p><pre><code>$ go build carestream.com\dental\csi
</code></pre><p>No output. Do go install for it.</p><pre><code>$ go install carestream.com\dental\csi
</code></pre><p>Get:</p><pre><code>$GOPATH\pkg\windows_amd64\carestream.com\dental\csi.a
</code></pre><p><strong>THE END</strong></p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/gozhua-qu-wang-xie-shu-ju-bing-cun-ru-mysqlhe-fan-hui-jsonshu-ju-ampltsi-ampgt.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">Go抓取网页数据并存入MySQL和返回json数据&lt;四&gt;</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/golangzai-mac-osshang-de-huan-jing-pei-zhi.html"><span class="next-text nav-default">Golang在MacOS上的环境配置</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>