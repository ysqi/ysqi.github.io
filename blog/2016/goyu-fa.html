<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Go语法 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="Go基础 变量 基本结构：var 变量名 变量类型 = 值 注：_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃 package main /* 全局变量 */ // 仅声明, 必要有va"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/goyu-fa.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="Go语法"><meta property="og:description" content="Go基础 变量 基本结构：var 变量名 变量类型 = 值 注：_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃 package main /* 全局变量 */ // 仅声明, 必要有va"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-fa.html"><meta property="article:published_time" content="2016-12-31T11:34:34&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:34:34&#43;08:00"><meta itemprop="name" content="Go语法"><meta itemprop="description" content="Go基础 变量 基本结构：var 变量名 变量类型 = 值 注：_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃 package main /* 全局变量 */ // 仅声明, 必要有va"><meta itemprop="datePublished" content="2016-12-31T11:34:34&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:34:34&#43;08:00"><meta itemprop="wordCount" content="4289"><meta itemprop="keywords" content="golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go语法"><meta name="twitter:description" content="Go基础 变量 基本结构：var 变量名 变量类型 = 值 注：_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃 package main /* 全局变量 */ // 仅声明, 必要有va"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Go语法</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 4289 字 </span><span class="more-meta">预计阅读 9 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><a href="#go基础">Go基础</a><ul><li><a href="#变量">变量</a></li><li><a href="#常量">常量</a></li><li><a href="#内置基本类型">内置基本类型</a><ul><li><a href="#boolean">Boolean</a></li><li><a href="#数值类型">数值类型</a></li><li><a href="#字符串">字符串</a><ul><li><a href="#定义">定义</a></li><li><a href="#修改">修改</a></li><li><a href="#连接">连接</a></li><li><a href="#原始格式输出">原始格式输出</a></li></ul></li></ul></li><li><a href="#错误类型">错误类型</a></li><li><a href="#go数据底层的存储">Go数据底层的存储</a></li><li><a href="#一些技巧">一些技巧</a><ul><li><a href="#分组声明">分组声明</a></li><li><a href="#iota枚举">iota枚举</a></li><li><a href="#私有和公有">私有和公有</a></li></ul></li><li><a href="#array-slice-map">array、slice、map</a><ul><li><a href="#array">array</a></li><li><a href="#slice">slice</a><ul><li><a href="#声明">声明</a></li><li><a href="#内置函数">内置函数</a></li><li><a href="#长度与容量">长度与容量</a></li><li><a href="#陷阱">陷阱</a></li></ul></li><li><a href="#map">map</a><ul><li><a href="#声明-1">声明</a></li><li><a href="#特点">特点</a></li></ul></li><li><a href="#make-new操作">make、new操作</a></li><li><a href="#零值">零值</a></li></ul></li><li><a href="#流程与函数">流程与函数</a><ul><li><a href="#流程控制">流程控制</a><ul><li><a href="#if">if</a></li><li><a href="#goto">goto</a></li><li><a href="#for">for</a><ul><li><a href="#while语句">while语句</a></li><li><a href="#break和continue">break和continue</a></li><li><a href="#range">range</a></li></ul></li><li><a href="#switch">switch</a></li></ul></li><li><a href="#函数">函数</a></li><li><a href="#变参">变参</a></li><li><a href="#传值与传指针">传值与传指针</a></li><li><a href="#defer">defer</a></li><li><a href="#函数作为值-类型">函数作为值、类型</a></li></ul></li></ul></li></ul></nav></div></div><div class="post-content"><h1 id="go基础">Go基础</h1><h2 id="变量">变量</h2><p>基本结构：<code>var 变量名 变量类型 = 值</code><br>注：<code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃</p><pre><code>package main

/* 全局变量 */
// 仅声明, 必要有var和变量类型
var a int
var b, c int

// 声明并初始化，变量类型可省略
var d int = 1
var e, f int = 1, 2
var g = 1 // 自动推断类型
var h, i = 1, &quot;string&quot; // 类型可以不一样

func main() {
    /* 局部变量特有的声明方式 */
    j := 1;
    k, l := 1, 2
}
</code></pre><h2 id="常量">常量</h2><p>常量可定义为数值、布尔值或字符串等类型。</p><pre><code>/* 全局和局部声明方式相同 */
const a int = 1
const b = 1
const c, d = 1, 2 &quot;string&quot; // 类型可以不一样
</code></pre><h2 id="内置基本类型">内置基本类型</h2><h3 id="boolean">Boolean</h3><p>布尔值的类型为bool，值是true或false，默认为false。</p><p>注：不能用0和非0表示true或false</p><h3 id="数值类型">数值类型</h3><pre><code>1. 整型 
    * 分为无符号和带符号，例如：int和uint
    * 8，16，32，64位，例如：int32和uint32
    * rune是int32的别称，byte是uint8的别称
2. 浮点型 float32和float64
3. 复数 complex64和complex128
注：不同类型之间不能进行运算
</code></pre><h3 id="字符串">字符串</h3><h4 id="定义">定义</h4><pre><code>var a string 
var b string = &quot;&quot; 
func test() {
    no, yes, maybe := &quot;no&quot;, &quot;yes&quot; 
}
</code></pre><h4 id="修改">修改</h4><pre><code>s := &quot;hello&quot;
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf(&quot;%s\n&quot;, s2)
</code></pre><h4 id="连接">连接</h4><pre><code>s := &quot;hello,&quot;
m := &quot; world&quot;
a := s + m
fmt.Printf(&quot;%s\n&quot;, a)
</code></pre><h4 id="原始格式输出">原始格式输出</h4><p>` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。</p><pre><code>m := `hello
    world`
</code></pre><h2 id="错误类型">错误类型</h2><p>Go内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误：</p><pre><code>err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {
    fmt.Print(err)
}
</code></pre><h2 id="go数据底层的存储">Go数据底层的存储</h2><p>下面这张图来源于Russ Cox Blog中一篇介绍Go数据结构的文章，大家可以看到这些基础类型底层都是分配了一块内存，然后存储了相应的值。</p><h2 id="一些技巧">一些技巧</h2><h3 id="分组声明">分组声明</h3><pre><code>import(
    &quot;fmt&quot;
    &quot;os&quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &quot;Go_&quot;
)

var(
    i int
    pi float32
    prefix string
)
</code></pre><h3 id="iota枚举">iota枚举</h3><p>Go里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，每调用一次加1：</p><pre><code>const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;
)

const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0

const ( 
  e, f, g = iota, iota, iota //e=0,f=0,g=0 iota在同一行值相同
)
</code></pre><blockquote><p>除非被显式设置为其它值或iota，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。</p></blockquote><h3 id="私有和公有">私有和公有</h3><p>大写字母开头的变量或函数，为公有，相当于java中的public<br>小写字母开头的变量或函数为，私有，相当于java中的private。</p><h2 id="array-slice-map">array、slice、map</h2><h3 id="array">array</h3><p>基本结构：<code>var 变量名 [长度]类型</code></p><ul><li>数组长度不能改变</li><li>长度也是数组类型的一部分，因此<a href="http://www.tuicool.com/articles/QrymYz">3</a>int与[4]int是不同的类型</li><li>当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。</li></ul><pre><code>var arr [10]int  // 声明了一个int类型的数组
a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组
b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0
c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度
</code></pre><h3 id="slice">slice</h3><h4 id="声明">声明</h4><p>基本结构：<code>var 变量名 []类型</code></p><p>slice是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。</p><pre><code>&lt;!-- 直接声明 --&gt;
var slice []int
var slice = []int{1, 2, 3}
slice := []byte {'a', 'b', 'c'}
&lt;!-- 从数组中截取 --&gt;
array := [3]byte {'a', 'b', 'c'}
slice := array[1, 2] // slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。 
</code></pre><h4 id="内置函数">内置函数</h4><ul><li>len 获取slice的长度</li><li>cap 获取slice的最大容量</li><li>append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice</li><li>copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</li></ul><h4 id="长度与容量">长度与容量</h4><pre><code>a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
s := a[0:]
s = append(s, 11, 22, 33)
sa := a[2:7]
sb := sa[3:5]
fmt.Println(a, len(a), cap(a))    //输出：[1 2 3 4 5 6 7 8 9 0] 10 10
fmt.Println(s, len(s), cap(s))    //输出：[1 2 3 4 5 6 7 8 9 0 11 22 33] 13 20
fmt.Println(sa, len(sa), cap(sa)) //输出：[3 4 5 6 7] 5 8
fmt.Println(sb, len(sb), cap(sb)) //输出：[6 7] 2 5
</code></pre><ul><li>长度为已存放个数，容量为可存放个数</li><li>对数组来说，长度和容量总是相等的</li><li>slice的容量可以大于长度，如果容量不足，将动态分配新的数组空间</li><li>array[i:j:k]，k - i为容量，k默认为数组长度</li></ul><h4 id="陷阱">陷阱</h4><p>当Slice的容量还有空闲的时候，append进来的元素会直接使用空闲的容量空间，但是一旦append进来的元素个数超过了原来指定容量值的时候，内存管理器就是重新开辟一个更大的内存空间，用于存储多出来的元素，并且会将原来的元素复制一份，放到这块新开辟的内存空间。</p><pre><code>a := []int{1, 2, 3, 4}
sa := a[1:3]
fmt.Printf(&quot;%p\n&quot;, sa) //输出：0xc0840046e0
sa = append(sa, 11, 22, 33)
fmt.Printf(&quot;%p\n&quot;, sa) //输出：0xc084003200
</code></pre><p><a href="http://www.tuicool.com/articles/QrymYz">参考链接</a></p><h3 id="map">map</h3><h4 id="声明-1">声明</h4><p>基本结构：<code>map[keyType]valueType</code></p><pre><code>m1 := make(map[string]string)
m1[&quot;aa&quot;] = &quot;bb&quot; // 添加
m2 := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
m2[&quot;C++&quot;] = 5 // 修改
delete(m2, &quot;C&quot;)  // 删除key为C的元素
len(m2) // 长度
</code></pre><h4 id="特点">特点</h4><ul><li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li><li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li><li>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li><li>map[key]，有两个返回值，第一个是value，第二个是是否存在对应的值</li></ul><h3 id="make-new操作">make、new操作</h3><p>make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。</p><ul><li>new返回的是指针</li><li>make返回初始化后的（非零）值</li></ul><h3 id="零值">零值</h3><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。 此处罗列 部分类型 的 “零值”</p><pre><code>int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre><h2 id="流程与函数">流程与函数</h2><h3 id="流程控制">流程控制</h3><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转</p><h4 id="if">if</h4><p>Go的if有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p><pre><code>// 计算获取值x,然后根据x返回的大小，判断是否大于10。
if x := computedValue(); x &gt; 10 {
    fmt.Println(&quot;x is greater than 10&quot;)
} else {
    fmt.Println(&quot;x is less than 10&quot;)
}

//这个地方如果这样调用就编译出错了，因为x是条件里面的变量
fmt.Println(x)
</code></pre><h4 id="goto">goto</h4><p>Go有goto语句——请明智地使用它。用goto跳转到必须在当前函数内定义的标签(大小写敏感)。例如假设这样一个循环：</p><pre><code>func myFunc() {
    i := 0
Here:   //这行的第一个词，以冒号结束作为标签
    println(i)
    i++
    goto Here   //跳转到Here去
}
</code></pre><h4 id="for">for</h4><p>Go里面最强大的一个控制逻辑就是for，它即可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。它的语法如下：</p><pre><code>/* expression1和expression3是变量声明或者函数调用返回值之类的，expression2是用来条件判断，expression1在循环开始之前调用，expression3在每轮循环结束之时调用。 */
for expression1; expression2; expression3 {
    //...
}

/* 例如 */
for index:= 0; index &lt; 10 ; index++ {
}
// 平行赋值
for a, b:= 0, 0; b &lt; 10 ; b++ {
}
</code></pre><h5 id="while语句">while语句</h5><pre><code>/* while语句 */
for ; sum &lt; 1000;  {
    sum += sum
}
// ;可省略
for sum &lt; 1000 {
    sum += sum
}
</code></pre><h5 id="break和continue">break和continue</h5><pre><code>/* break和continue与java一致 */
for index := 10; index&gt;0; index-- {
    if index == 5{
        break // 或者continue
    }
    fmt.Println(index)
}
// break打印出来10、9、8、7、6
// continue打印出来10、9、8、7、6、4、3、2、1
</code></pre><h5 id="range">range</h5><pre><code>/* for配合range可以用于读取slice和map的数据 */
// 第一个返回值是key，第二个返回值是value
// 如果是slice，那么key为下标
for k,v:=range map {
    fmt.Println(&quot;map's key:&quot;,k)
    fmt.Println(&quot;map's val:&quot;,v)
}
</code></pre><h4 id="switch">switch</h4><p>与java不同的是，默认每个<code>case</code>执行完毕后会跳出<code>switch语句</code>，如果希望继续执行下一个<code>case</code>，需要加入<code>fallthrough</code>关键字</p><pre><code>i := 10
switch i {
case 1:
    fmt.Println(&quot;i is equal to 1&quot;)
case 2, 3, 4:
    fmt.Println(&quot;i is equal to 2, 3 or 4&quot;)
case 10:
    fmt.Println(&quot;i is equal to 10&quot;)
    fallthrough
default:
    fmt.Println(&quot;------------------------&quot;)
}
</code></pre><h3 id="函数">函数</h3><pre><code>/* 基本结构 */
func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    //这里是处理逻辑代码
    //返回多个值
    return output1, output2
}

/* output1和output2，可以不声明，但必须注明返回类型*/
func funcName(input1 type1, input2 type2) (type1, type2) {

    return &quot;&quot;, &quot;&quot; 
}

/* 如果只有一个返回值且不声明返回值变量，可以这样写 */
func funcName(input1 type1, input2 type2) type {

}

/* 没有返回值，可全部省略 */
func funcName(input1 type1, input2 type2) {

}

/* 前后参数类型相同，可省略前面的参数类型*/
func funcName(input1, input2 int, input3 string, input4, input5 float32) (output1, output2 int){

}

/* 官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。 */
func SumAndProduct(A, B int) (add int, Multiplied int) {
    add = A+B
    Multiplied = A*B
    // 这里也是个特别的地方
    return
}
</code></pre><h3 id="变参">变参</h3><p>基本结构：<code>func myfunc(arg ...int) {}</code></p><ul><li>参数的类型全部是int</li><li>变量arg是一个int的slice</li></ul><pre><code>for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</code></pre><h3 id="传值与传指针">传值与传指针</h3><ul><li>函数的参数，传入的都是copy</li><li>即使传入的是指针，也是指针的copy</li></ul><p>指针的优点</p><ul><li>传指针使得多个函数能操作同一个对象。</li><li>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li><li>Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）</li></ul><pre><code>package main
import &quot;fmt&quot;

//简单的一个函数，实现了参数+1的操作
func add1(a *int) int { // 请注意，
    *a = *a+1 // 修改了a的值
    return *a // 返回新值
}

func main() {
    x := 3

    fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;

    x1 := add1(&amp;x)  // 调用 add1(&amp;x) 传x的地址

    fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;
    fmt.Println(&quot;x = &quot;, x)    // 应该输出 &quot;x = 4&quot;
}
</code></pre><h3 id="defer">defer</h3><ul><li>defer语句会在函数返回前执行</li></ul><pre><code>func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    defer file.Close()
    if failureX {
        return false
    }
    if failureY {
        return false
    }
    return true
}
</code></pre><ul><li>defer是采用后进先出模式，所以如下代码会输出4 3 2 1 0</li></ul><pre><code>for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</code></pre><h3 id="函数作为值-类型">函数作为值、类型</h3><p>基本结构：<code>type typeName func(input1 inputType1 , input2 inputType2) (result1 resultType1)</code></p><ul><li>拥有相同参数列表和返回值列表的函数，属于同一函数类型。比如下面例子中的isOdd和isEven函数。</li></ul><pre><code>package main
import &quot;fmt&quot;

type testInt func(int) bool // 声明了一个函数类型

func isOdd(integer int) bool {
    if integer%2 == 0 {
        return false
    }
    return true
}

func isEven(integer int) bool {
    if integer%2 == 0 {
        return true
    }
    return false
}

// 声明的函数类型在这个地方当做了一个参数

func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}

func main(){
    slice := []int {1, 2, 3, 4, 5, 7}
    fmt.Println(&quot;slice = &quot;, slice)
    odd := filter(slice, isOdd)    // 函数当做值来传递了
    fmt.Println(&quot;Odd elements of slice are: &quot;, odd)
    even := filter(slice, isEven)  // 函数当做值来传递了
    fmt.Println(&quot;Even elements of slice are: &quot;, even)
}
</code></pre></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/golang-huan-jing-pei-zhi-jian-yi.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">golang环境配置建议</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/goyu-yan-de-biao-shi-fu-guan-jian-zi-zi-mian-liang-lei-xing.html"><span class="next-text nav-default">Go语言的标识符、关键字、字面量、类型</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>