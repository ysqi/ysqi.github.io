<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>TiKV源码解析系列-如何使用Raft - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="TiKV 源码解析系列——如何使用 Raft 本系列文章主要面向 TiKV 社区开发者，重点介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读之后，能对 TiKV 项目有"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="TiKV源码解析系列-如何使用Raft"><meta property="og:description" content="TiKV 源码解析系列——如何使用 Raft 本系列文章主要面向 TiKV 社区开发者，重点介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读之后，能对 TiKV 项目有"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html"><meta property="article:published_time" content="2016-12-31T11:32:35&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:32:35&#43;08:00"><meta itemprop="name" content="TiKV源码解析系列-如何使用Raft"><meta itemprop="description" content="TiKV 源码解析系列——如何使用 Raft 本系列文章主要面向 TiKV 社区开发者，重点介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读之后，能对 TiKV 项目有"><meta itemprop="datePublished" content="2016-12-31T11:32:35&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:32:35&#43;08:00"><meta itemprop="wordCount" content="2855"><meta itemprop="keywords" content="mysql,rust,golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="TiKV源码解析系列-如何使用Raft"><meta name="twitter:description" content="TiKV 源码解析系列——如何使用 Raft 本系列文章主要面向 TiKV 社区开发者，重点介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读之后，能对 TiKV 项目有"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">TiKV源码解析系列-如何使用Raft</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 2855 字 </span><span class="more-meta">预计阅读 6 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><a href="#tikv-源码解析系列-如何使用-raft">TiKV 源码解析系列——如何使用 Raft</a><ul><li><ul><li><a href="#概述">概述</a></li><li><a href="#架构">架构</a></li><li><a href="#raft">Raft</a><ul><li><a href="#storage">Storage</a></li><li><a href="#config">Config</a></li><li><a href="#rawnode">RawNode</a></li></ul></li></ul></li></ul></li></ul></nav></div></div><div class="post-content"><h1 id="tikv-源码解析系列-如何使用-raft">TiKV 源码解析系列——如何使用 Raft</h1><p>本系列文章主要面向 TiKV 社区开发者，重点介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读之后，能对 TiKV 项目有一个初步了解，更好的参与进入 TiKV 的开发中。<br>需要注意，TiKV 使用 Rust 语言编写，用户需要对 Rust 语言有一个大概的了解。另外，本系列文章并不会涉及到 TiKV 中心控制服务 Placement Driver(PD) 的详细介绍，但是会说明一些重要流程 TiKV 是如何与 PD 交互的。<br>TiKV 是一个分布式的 KV 系统，它采用 Raft 协议保证数据的强一致性，同时使用 MVCC + 2PC 的方式实现了分布式事务的支持。</p><h3 id="概述">概述</h3><p>本文档主要面向 TiKV 社区开发者，主要介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读文档之后，能对 TiKV 项目有一个初步了解，更好的参与进入 TiKV 的开发中。</p><p>需要注意，TiKV 使用 <a href="https://www.rust-lang.org/zh-CN/">Rust</a> 语言编写，用户需要对 Rust 语言有一个大概的了解。另外，本文档并不会涉及到 TiKV 中心控制服务 Placement Driver(PD) 的详细介绍，但是会说明一些重要流程 TiKV 是如何与 PD 交互的。</p><p>TiKV 是一个分布式的 KV 系统，它采用 Raft 协议保证数据的强一致性，同时使用 MVCC + 2PC 的方式实现了分布式事务的支持。</p><h3 id="架构">架构</h3><p>TiKV 的整体架构比较简单，如下：</p><p><strong>Placement Driver</strong> : Placement Driver (PD) 负责整个集群的管理调度。</p><p><strong>Node</strong> : Node 可以认为是一个实际的物理机器，每个 Node 负责一个或者多个 Store。</p><p><strong>Store</strong> : Store 使用 RocksDB 进行实际的数据存储，通常一个 Store 对应一块硬盘。</p><p><strong>Region</strong> : Region 是数据移动的最小单元，对应的是 Store 里面一块实际的数据区间。每个 Region 会有多个副本（replica），每个副本位于不同的 Store ，而这些副本组成了一个 Raft group。</p><h3 id="raft">Raft</h3><p>TiKV 使用 Raft 算法实现了分布式环境下面数据的强一致性，关于 Raft，可以参考论文 “<a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm</a>” 以及<a href="https://raft.github.io/">官网</a>，这里不做详细的解释。简单理解，Raft 是一个 replication log + State Machine 的模型，我们只能通过 leader 进行写入，leader 会将 command 通过 log 的形式复制到 followers，当集群的大多数节点都收到了这个 log，我们就认为这个 log 是 committed，可以 apply 到 State Machine 里面。</p><p>TiKV 的 Raft 主要移植 <a href="https://github.com/coreos/etcd/tree/master/raft">etcd Raft</a>，支持 Raft 所有功能，包括：</p><ul><li><p>Leader election</p></li><li><p>Log replicationLog compaction</p></li><li><p>Membership changesLeader transfer</p></li><li><p>Linearizable / Lease read</p></li></ul><p>这里需要注意，TiKV 以及 etcd 对于 membership change 的处理，跟 Raft 论文是稍微有一点不一样的，主要在于 TiKV 的 membership change 只有在 log applied 的时候生效，这样主要的目的是为了实现简单，但有一个风险在于如果我们只有两个节点，要从里面移掉一个节点，如果一个 follower 还没收到 ConfChange 的 log entry，leader 就当掉并且不可恢复了，整个集群就没法工作了。所以通常我们都建议用户部署 3 个或者更多个奇数个节点。</p><p>Raft 库是一个独立的库，用户也可以非常方便的将其直接嵌入到自己的应用程序，而仅仅只需要自行处理存储以及消息的发送。这里简单介绍一下如何使用 Raft，代码在 TiKV 源码目录的 /src/raft 下面。</p><h4 id="storage">Storage</h4><p>首先，我们需要定义自己的 Storage，Storage 主要用来存储 Raft 相关数据，trait 定义如下：</p><pre><code>pub trait Storage {
    fn initial_state(&amp;self) -&gt; Result&lt;RaftState&gt;;
    fn entries(&amp;self, low: u64, high: u64, max_size: u64) -&gt; Result&lt;Vec&lt;Entry&gt;&gt;;
    fn term(&amp;self, idx: u64) -&gt; Result&lt;u64&gt;;
    fn first_index(&amp;self) -&gt; Result&lt;u64&gt;;
    fn last_index(&amp;self) -&gt; Result&lt;u64&gt;;
    fn snapshot(&amp;self) -&gt; Result&lt;Snapshot&gt;;
}
</code></pre><p>我们需要实现自己的 Storage trait，这里详细解释一下各个接口的含义：</p><p>initial_state：初始化 Raft Storage 的时候调用，它会返回一个 RaftState，RaftState 的定义如下：</p><pre><code>pub struct RaftState {
    pub hard_state: HardState,
    pub conf_state: ConfState,
}
</code></pre><p>HardState 和 ConfState 是 protobuf，定义：</p><pre><code>message HardState {
    optional uint64 term   = 1; 
    optional uint64 vote   = 2; 
    optional uint64 commit = 3; 
}

message ConfState {
    repeated uint64 nodes = 1;
}
</code></pre><p>在 HardState 里面，保存着该 Raft 节点最后一次保存的 term 信息，之前 vote 的哪一个节点，以及已经 commit 的 log index。而 ConfState 则是保存着 Raft 集群所有的节点 ID 信息。</p><p>在外面调用 Raft 相关逻辑的时候，用户需要自己处理 RaftState 的持久化。</p><p><strong>entries</strong>: 得到 [low, high) 区间的 Raft log entry，通过 max_size 来控制最多返回多少个 entires。</p><p>term，first_index 和 last_index 分别是得到当前的 term，以及最小和最后的 log index。</p><p><strong>snapshot</strong>：得到当前的 Storage 的一个 snapshot，有时候，当前的 Storage 数据量已经比较大，生成 snapshot 会比较耗时，所以我们可能得在另一个线程异步去生成，而不用阻塞当前 Raft 线程，这时候，可以返回 SnapshotTemporarilyUnavailable 错误，这时候，Raft 就知道正在准备 snapshot，会一段时间之后再次尝试。</p><p>需要注意，上面的 Storage 接口只是 Raft 库需要的，实际我们还会用这个 Storage 存储 raft log 等数据，所以还需要单独提供其他的接口。在 Raft storage.rs 里面，我们提供了一个 MemStorage，用于测试，大家也可以参考 MemStorage 来实现自己的 Storage。</p><h4 id="config">Config</h4><p>在使用 Raft 之前，我们需要知道 Raft 一些相关的配置，在 Config 里面定义，这里只列出需要注意的：</p><pre><code>pub struct Config {
    pub id: u64,
    pub election_tick: usize,
    pub heartbeat_tick: usize,
    pub applied: u64,
    pub max_size_per_msg: u64,
    pub max_inflight_msgs: usize,
}
</code></pre><p><strong>id</strong>: Raft 节点的唯一标识，在一个 Raft 集群里面，id 是不可能重复的。在 TiKV 里面，id 的通过 PD 来保证全局唯一。</p><p><strong>election_tick</strong>：当 follower 在 election_tick 的时间之后还没有收到 leader 发过来的消息，那么就会重新开始选举，TiKV 默认使用 50。</p><p><strong>heartbeat_tick</strong>: leader 每隔 hearbeat_tick 的时间，都会给 follower 发送心跳消息。默认 10。</p><p><strong>applied</strong>: applied 是上一次已经被 applied 的 log index。</p><p><strong>max_size_per_msg</strong>: 限制每次发送的最大 message size。默认 1MB。</p><p><strong>max_inflight_msgs</strong>: 限制复制时候最大的 in-flight 的 message 的数量。默认 256。</p><p>这里详细解释一下 tick 的含义，TiKV 的 Raft 是定时驱动的，假设我们每隔 100ms 调用一次 Raft tick，那么当调用到 headtbeat_tick 的 tick 次数之后，leader 就会给 follower 发送心跳。</p><h4 id="rawnode">RawNode</h4><p>我们通过 RawNode 来使用 Raft，RawNode 的构造函数如下：</p><pre><code>pub fn new(config: &amp;Config, store: T, peers: &amp;[Peer]) -&gt; Result&lt;RawNode&lt;T&gt;&gt; 
</code></pre><p>我们需要定义 Raft 的 Config，然后传入一个实现好的 Storage，peers 这个参数只是用于测试，实际要传空。生成好 RawNode 对象之后，我们就可以使用 Raft 了。我们关注如下几个函数：</p><p><strong>tick</strong>: 我们使用 tick 函数定期驱动 Raft，在 TiKV，我们每隔 100ms 调用一次 tick。</p><p><strong>propose</strong>: leader 通过 propose 命令将 client 发过来的 command 写入到 raft log，并复制给其他节点。</p><p><strong>propose_conf_change</strong>: 跟 propose 类似，只是单独用来处理 ConfChange 命令。</p><p><strong>step</strong>: 当节点收到其他节点发过来的 message，主动调用驱动 Raft。</p><p><strong>has_ready</strong>: 用来判断一个节点是不是 ready 了。</p><p><strong>ready</strong>: 得到当前节点的 ready 状态，我们会在之前用 has_ready 来判断一个 RawNode 是否 ready。</p><p><strong>apply_conf_change</strong>: 当一个 ConfChange 的 log 被成功 applied，需要主动调用这个驱动 Raft。</p><p><strong>advance</strong>: 告诉 Raft 已经处理完 ready，开始后续的迭代。</p><p>对于 RawNode，我们这里重点关注下 ready 的概念，ready 的定义如下：</p><pre><code>pub struct Ready {
    pub ss: Option&lt;SoftState&gt;,
    pub hs: Option&lt;HardState&gt;,
    pub entries: Vec&lt;Entry&gt;,
    pub snapshot: Snapshot,
    pub committed_entries: Vec&lt;Entry&gt;,
    pub messages: Vec&lt;Message&gt;,
}
</code></pre><p><strong>ss</strong>: 如果 SoftState 变更，譬如添加，删除节点，ss 就不会为空。</p><p><strong>hs</strong>: 如果 HardState 有变更，譬如重新 vote，term 增加，hs 就不会为空。</p><p><strong>entries</strong>: 需要在 messages 发送之前存储到 Storage。</p><p><strong>snapshot</strong>: 如果 snapshot 不是 empty，则需要存储到 Storage。</p><p><strong>committed_entries</strong>: 已经被 committed 的 raft log，可以 apply 到 State Machine 了。</p><p><strong>messages</strong>: 给其他节点发送的消息，通常需要在 entries 保存成功之后才能发送，但对于 leader 来说，可以先发送 messages，在进行 entries 的保存，这个是 Raft 论文里面提到的一个优化方式，TiKV 也采用了。</p><p>当外部发现一个 RawNode 已经 ready 之后，得到 Ready，处理如下：</p><ol><li><p>持久化非空的 ss 以及 hs。</p></li><li><p>如果是 leader，首先发送 messages。</p></li><li><p>如果 snapshot 不为空，保存 snapshot 到 Storage，同时将 snapshot 里面的数据异步应用到 State Machine（这里虽然也可以同步 apply，但 snapshot 通常比较大，同步会 block 线程）。</p></li><li><p>将 entries 保存到 Storage 里面。</p></li><li><p>如果是 follower，发送 messages。</p></li><li><p>将 committed_entries apply 到 State Machine。</p></li><li><p>调用 advance 告知 Raft 已经处理完 ready。</p></li></ol><p>（未完待续…）</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/mysql.html">mysql</a> <a href="/tags/rust.html">rust</a> <a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--multi-raft-she-ji-yu-shi-xian.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">TiKV源码解析系列-multi-raft设计与实现</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/da-jian-golangban-ssfu-wu.html"><span class="next-text nav-default">搭建golang版ss服务</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>