<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>关于Golang中database_sql包的学习笔记 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没有提供db mapping的组件，所以在g"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="关于Golang中database_sql包的学习笔记"><meta property="og:description" content="因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没有提供db mapping的组件，所以在g"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html"><meta property="article:published_time" content="2016-12-31T11:34:24&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:34:24&#43;08:00"><meta itemprop="name" content="关于Golang中database_sql包的学习笔记"><meta itemprop="description" content="因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没有提供db mapping的组件，所以在g"><meta itemprop="datePublished" content="2016-12-31T11:34:24&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:34:24&#43;08:00"><meta itemprop="wordCount" content="3079"><meta itemprop="keywords" content="sql,数据库,golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="关于Golang中database_sql包的学习笔记"><meta name="twitter:description" content="因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没有提供db mapping的组件，所以在g"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">关于Golang中database_sql包的学习笔记</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 3079 字 </span><span class="more-meta">预计阅读 7 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#概述">概述</a></li><li><a href="#使用db">使用DB</a><ul><li><a href="#导入driver">导入driver</a></li><li><a href="#连接db">连接DB</a></li><li><a href="#读取db">读取DB</a></li><li><a href="#单行query">单行Query</a></li></ul></li><li><a href="#修改数据-事务">修改数据，事务</a><ul><li><a href="#事务">事务</a></li></ul></li><li><a href="#prepared-statements">Prepared Statements</a><ul><li><a href="#prepared-statements-and-connection">Prepared Statements and Connection</a></li><li><a href="#在transaction中使用ps">在Transaction中使用PS</a></li></ul></li><li><a href="#处理error">处理Error</a><ul><li><a href="#循环rows的error">循环Rows的Error</a></li><li><a href="#关闭resultsets时的error">关闭Resultsets时的error</a></li><li><a href="#queryrow-的error">QueryRow()的error</a></li><li><a href="#分析数据库error">分析数据库Error</a></li><li><a href="#连接错误">连接错误</a></li></ul></li><li><a href="#null值处理">NULL值处理</a></li><li><a href="#未知column">未知Column</a></li><li><a href="#关于连接池">关于连接池</a></li></ul></li></ul></nav></div></div><div class="post-content"><blockquote><p>因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没有提供db mapping的组件，所以在github上搜了很多ORM来学习，在<code>jmoiron/sqlx</code>中发现了一篇比较详细介绍<code>database/sql</code>这个包的文章，拿来和大家分享。本文并不是按字句的翻译，如果哪里表述不清楚建议阅读原文 <a href="http://go-database-sql.org/index.html">原文地址</a></p></blockquote><h2 id="概述">概述</h2><p><code>sql.DB</code>不是一个连接，它是数据库的抽象接口。它可以根据driver打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果你没有把连接释放回连接池，会导致过多连接使系统资源耗尽。</p><h2 id="使用db">使用DB</h2><h3 id="导入driver">导入driver</h3><p>这里使用的是<a href="https://github.com/go-sql-driver/mysql">MySQL drivers</a></p><pre><code>import (
    &quot;database/sql&quot;
    _ &quot;github.com/go-sql-driver/mysql&quot;
)
</code></pre><h3 id="连接db">连接DB</h3><pre><code>func main() {
    db, err := sql.Open(&quot;mysql&quot;,
        &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
}
</code></pre><p><code>sql.Open</code>的第一个参数是driver名称，第二个参数是driver连接数据库的信息，各个driver可能不同。DB不是连接，并且只有当需要使用时才会创建连接，如果想立即验证连接，需要用<code>Ping()</code>方法，如下：</p><pre><code>err = db.Ping()
if err != nil {
    // do something here
}
</code></pre><p>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</p><h3 id="读取db">读取DB</h3><p>如果方法包含<code>Query</code>，那么这个方法是用于查询并返回rows的。其他情况应该用<code>Exec()</code>。</p><pre><code>var (
    id int
    name string
)
rows, err := db.Query(&quot;select id, name from users where id = ?&quot;, 1)
if err != nil {
    log.Fatal(err)
}
defer rows.Close()
for rows.Next() {
    err := rows.Scan(&amp;id, &amp;name)
    if err != nil {
        log.Fatal(err)
    }
    log.Println(id, name)
}
err = rows.Err()
if err != nil {
    log.Fatal(err)
}
</code></pre><p>上面代码的过程为：<code>db.Query()</code>表示向数据库发送一个query，<code>defer rows.Close()</code>非常重要，遍历rows使用<code>rows.Next()</code>， 把遍历到的数据存入变量使用<code>rows.Scan()</code>, 遍历完成后检查error。有几点需要注意：</p><ol><li>检查遍历是否有error</li><li>结果集(rows)未关闭前，底层的连接处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部EOF错误，自动调用<code>rows.Close()</code>，但是如果提前退出循环，rows不会关闭，连接不会回到连接池中，连接也不会关闭。所以手动关闭非常重要。<code>rows.Close()</code>可以多次调用，是无害操作。</li></ol><h3 id="单行query">单行Query</h3><p>err在<code>Scan</code>后才产生，所以可以如下写：</p><pre><code>var name string
err = db.QueryRow(&quot;select name from users where id = ?&quot;, 1).Scan(&amp;name)
if err != nil {
    log.Fatal(err)
}
fmt.Println(name)
</code></pre><h2 id="修改数据-事务">修改数据，事务</h2><p>一般用Prepared Statements和<code>Exec()</code>完成<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>操作。</p><pre><code>stmt, err := db.Prepare(&quot;INSERT INTO users(name) VALUES(?)&quot;)
if err != nil {
    log.Fatal(err)
}
res, err := stmt.Exec(&quot;Dolly&quot;)
if err != nil {
    log.Fatal(err)
}
lastId, err := res.LastInsertId()
if err != nil {
    log.Fatal(err)
}
rowCnt, err := res.RowsAffected()
if err != nil {
    log.Fatal(err)
}
log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)
</code></pre><h3 id="事务">事务</h3><p><code>db.Begin()</code>开始事务，<code>Commit()</code> 或 <code>Rollback()</code>关闭事务。<code>Tx</code>从连接池中取出一个连接，在关闭之前都是使用这个连接。Tx不能和DB层的<code>BEGIN</code>, <code>COMMIT</code>混合使用。</p><p>如果你需要通过多条语句修改连接状态，你必须使用Tx，例如：</p><ul><li>创建仅对单个连接可见的临时表</li><li>设置变量，例如<code>SET @var := somevalue</code></li><li>改变连接选项，例如字符集，超时</li></ul><h2 id="prepared-statements">Prepared Statements</h2><h3 id="prepared-statements-and-connection">Prepared Statements and Connection</h3><p>在数据库层面，Prepared Statements是和单个数据库连接绑定的。客户端发送一个有占位符的statement到服务端，服务器返回一个statement ID，然后客户端发送ID和参数来执行statement。</p><p>在GO中，连接不直接暴露，你不能为连接绑定statement，而是只能为DB或Tx绑定。<code>database/sql</code>包有自动重试等功能。当你生成一个Prepared Statement</p><ol><li>自动在连接池中绑定到一个空闲连接</li><li><code>Stmt</code>对象记住绑定了哪个连接</li><li>执行<code>Stmt</code>时，尝试使用该连接。如果不可用，例如连接被关闭或繁忙中，会自动re-prepare，绑定到另一个连接。</li></ol><p>这就导致在高并发的场景，过度使用statement可能导致statement泄漏，statement持续重复prepare和re-prepare的过程，甚至会达到服务器端statement数量上限。</p><p>某些操作使用了PS，例如<code>db.Query(sql, param1, param2)</code>, 并在最后自动关闭statement。</p><p>有些场景不适合用statement：</p><ol><li>数据库不支持。例如Sphinx，MemSQL。他们支持MySQL wire protocol, 但不支持&rdquo;binary&rdquo; protocol。</li><li>statement不需要重用很多次，并且有其他方法保证安全。<a href="https://vividcortex.com/blog/2014/11/19/analyzing-prepared-statement-performance-with-vividcortex/">例子</a></li></ol><h3 id="在transaction中使用ps">在Transaction中使用PS</h3><p>PS在Tx中唯一绑定一个连接，不会re-prepare。</p><p>Tx和statement不能分离，在DB中创建的statement也不能在Tx中使用，因为他们必定不是使用同一个连接使用Tx必须十分小心，例如下面的代码：</p><pre><code>tx, err := db.Begin()
if err != nil {
    log.Fatal(err)
}
defer tx.Rollback()
stmt, err := tx.Prepare(&quot;INSERT INTO foo VALUES (?)&quot;)
if err != nil {
    log.Fatal(err)
}
defer stmt.Close() // danger!
for i := 0; i &lt; 10; i++ {
    _, err = stmt.Exec(i)
    if err != nil {
        log.Fatal(err)
    }
}
err = tx.Commit()
if err != nil {
    log.Fatal(err)
}
// stmt.Close() runs here!
</code></pre><p><code>*sql.Tx</code>一旦释放，连接就回到连接池中，这里stmt在关闭时就无法找到连接。所以必须在Tx commit或rollback之前关闭statement。</p><h2 id="处理error">处理Error</h2><h3 id="循环rows的error">循环Rows的Error</h3><p>如果循环中发生错误会自动运行<code>rows.Close()</code>，用<code>rows.Err()</code>接收这个错误，Close方法可以多次调用。循环之后判断error是非常必要的。</p><pre><code>for rows.Next() {
    // ...
}
if err = rows.Err(); err != nil {
    // handle the error here
}
</code></pre><h3 id="关闭resultsets时的error">关闭Resultsets时的error</h3><p>如果你在rows遍历结束之前退出循环，必须手动关闭Resultset，并且接收error。</p><pre><code>for rows.Next() {
    // ...
    break; // whoops, rows is not closed! memory leak...
}
// do the usual &quot;if err = rows.Err()&quot; [omitted here]...
// it's always safe to [re?]close here:
if err = rows.Close(); err != nil {
    // but what should we do if there's an error?
    log.Println(err)
}
</code></pre><h3 id="queryrow-的error">QueryRow()的error</h3><pre><code>var name string
err = db.QueryRow(&quot;select name from users where id = ?&quot;, 1).Scan(&amp;name)
if err != nil {
    log.Fatal(err)
}
fmt.Println(name)
</code></pre><p>如果id为1的不存在，err为sql.ErrNoRows，一般应用中不存在的情况都需要单独处理。此外，Query返回的错误都会延迟到Scan被调用，所以应该写成如下代码：</p><pre><code>var name string
err = db.QueryRow(&quot;select name from users where id = ?&quot;, 1).Scan(&amp;name)
if err != nil {
    if err == sql.ErrNoRows {
        // there were no rows, but otherwise no error occurred
    } else {
        log.Fatal(err)
    }
}
fmt.Println(name)
</code></pre><p>把空结果当做Error处理是为了强行让程序员处理结果为空的情况</p><h3 id="分析数据库error">分析数据库Error</h3><p>各个数据库处理方式不太一样，mysql为例：</p><pre><code>if driverErr, ok := err.(*mysql.MySQLError); ok { 
    // Now the error number is accessible directly
    if driverErr.Number == 1045 {
        // Handle the permission-denied error
    }
}
</code></pre><p><code>MySQLError</code>, <code>Number</code>都是DB特异的，别的数据库可能是别的类型或字段。这里的数字可以替换为常量，例如这个包 <a href="https://github.com/VividCortex/mysqlerr">MySQL error numbers maintained by VividCortex</a></p><h3 id="连接错误">连接错误</h3><h2 id="null值处理">NULL值处理</h2><p>简单说就是设计数据库的时候不要出现null，处理起来非常费力。Null的type很有限，例如没有<code>sql.NullUint64</code>; null值没有默认零值。</p><pre><code>for rows.Next() {
    var s sql.NullString
    err := rows.Scan(&amp;s)
    // check err
    if s.Valid {
       // use s.String
    } else {
       // NULL value
    }
}
</code></pre><h2 id="未知column">未知Column</h2><p><code>rows.Columns()</code>的使用，用于处理不能得知结果字段个数或类型的情况，例如：</p><pre><code>cols, err := rows.Columns()
if err != nil {
    // handle the error
} else {
    dest := []interface{}{ // Standard MySQL columns
        new(uint64), // id
        new(string), // host
        new(string), // user
        new(string), // db
        new(string), // command
        new(uint32), // time
        new(string), // state
        new(string), // info
    }
    if len(cols) == 11 {
        // Percona Server
    } else if len(cols) &gt; 8 {
        // Handle this case
    }
    err = rows.Scan(dest...)
    // Work with the values in dest
}

cols, err := rows.Columns() // Remember to check err afterwards
vals := make([]interface{}, len(cols))
for i, _ := range cols {
    vals[i] = new(sql.RawBytes)
}
for rows.Next() {
    err = rows.Scan(vals...)
    // Now you can check each element of vals for nil-ness,
    // and you can use type introspection and type assertions
    // to fetch the column into a typed variable.
}
</code></pre><h2 id="关于连接池">关于连接池</h2><ol><li>避免错误操作，例如LOCK TABLE后用 INSERT会死锁，因为两个操作不是同一个连接，insert的连接没有table lock。</li><li>当需要连接，且连接池中没有可用连接时，新的连接就会被创建。</li><li>默认没有连接上限，你可以设置一个，但这可能会导致数据库产生错误“too many connections”</li><li><code>db.SetMaxIdleConns(N)</code>设置最大空闲连接数</li><li><code>db.SetMaxOpenConns(N)</code>设置最大打开连接数</li><li>长时间保持空闲连接可能会导致db timeout</li></ol></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/sql.html">sql</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a> <a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/kingshard--yi-ge-zhi-chi-shardingde-mysql-proxyxiang-mu.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">kingshard--一个支持sharding的MySQLProxy项目</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/tong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html"><span class="next-text nav-default">通过Mesos、Docker和Go使用300行代码创建一个分布式系统</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2020 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="www.miitbeian.gov.cn">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script><script src="https://xiongzhang.baidu.com/sdk/c.js?appid=1614189312904082"></script><script>cambrian.render('tail')</script></body></html>