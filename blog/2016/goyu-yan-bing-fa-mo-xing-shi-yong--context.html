<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Go语言并发模型:使用context - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="简介 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-shi-yong--context.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="Go语言并发模型:使用context"><meta property="og:description" content="简介 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-shi-yong--context.html"><meta property="article:published_time" content="2016-12-31T11:33:10&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:33:10&#43;08:00"><meta itemprop="name" content="Go语言并发模型:使用context"><meta itemprop="description" content="简介 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服"><meta itemprop="datePublished" content="2016-12-31T11:33:10&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:33:10&#43;08:00"><meta itemprop="wordCount" content="3610"><meta itemprop="keywords" content="context,golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go语言并发模型:使用context"><meta name="twitter:description" content="简介 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Go语言并发模型:使用context</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 3610 字 </span><span class="more-meta">预计阅读 8 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#简介">简介</a></li><li><a href="#阅读建议">阅读建议</a></li><li><a href="#package-context">package context</a></li><li><a href="#继承-context">继承 context</a></li><li><a href="#一个栗子-google-web-search">一个栗子：Google Web Search</a><ul><li><a href="#深入-server-程序">深入 server 程序</a></li><li><a href="#深入-userip-包">深入 userip 包</a></li><li><a href="#深入-google-包">深入 google 包</a></li></ul></li><li><a href="#在自己的代码中使用-context">在自己的代码中使用 <code>Context</code></a></li><li><a href="#结论">结论</a></li><li><a href="#相关链接">相关链接</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="简介">简介</h2><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><p>在Google 内部，我们开发了 <code>Context</code> 包，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。你可以通过 <code>go get golang.org/x/net/context</code> 命令获取这个包。本文要讲的就是如果使用这个包，同时也会提供一个完整的例子。</p><h2 id="阅读建议">阅读建议</h2><p>本文内容涉及到了 done channel，如果你不了解这个概念，那么请先阅读 <a href="https://segmentfault.com/a/1190000006261218">&ldquo;Go语言并发模型：像Unix Pipe那样使用channel&rdquo;</a>。</p><p>由于访问 <code>golang.org/x/net/context</code> 需要梯子，你可以访问它在 github 上的 <a href="https://github.com/golang/net">mirror</a>。<br>如果要下载本文中的代码，可以查看文章末尾的“相关链接”环节。</p><h2 id="package-context">package context</h2><p>context 包的核心是 struct Context，声明如下：</p><pre><code>// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
    // Done returns a channel that is closed when this `Context` is canceled
    // or times out.
    Done() &lt;-chan struct{}

    // Err indicates why this Context was canceled, after the Done channel
    // is closed.
    Err() error

    // Deadline returns the time when this Context will be canceled, if any.
    Deadline() (deadline time.Time, ok bool)

    // Value returns the value associated with key or nil if none.
    Value(key interface{}) interface{}
}
</code></pre><p>注意: 这里我们对描述进行了简化，更详细的描述查看 <a href="http://godoc.org/golang.org/x/net/context">godoc:context</a></p><p><code>Done</code> 方法返回一个 channel，这个 channel 对于以 <code>Context</code> 方式运行的函数而言，是一个取消信号。当这个 channel 关闭时，上面提到的这些函数应该终止手头的工作并立即返回。 之后，<code>Err</code> 方法会返回一个错误，告知为什么 <code>Context</code> 被取消。关于 <code>Done</code> channel 的更多细节查看上一篇文章 <a href="https://segmentfault.com/a/1190000006261218">&ldquo;Go语言并发模型：像Unix Pipe那样使用channel&rdquo;</a>。</p><p>一个 <code>Context</code> 不能拥有 <code>Cancel</code> 方法，同时我们也只能 <code>Done</code> channel 接收数据。背后的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 一个典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。 作为一个折中，<code>WithCancel</code> 函数 (后面会细说) 提供了一种取消新的 <code>Context</code> 的方法。</p><p><code>Context</code> 对象是线程安全的，你可以把一个 <code>Context</code> 对象传递给任意个数的 gorotuine，<br>对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><p><code>Deadline</code> 方法允许函数确定它们是否应该开始工作。如果剩下的时间太少，也许这些函数就不值得启动。代码中，我们也可以使用 <code>Deadline</code> 对象为 I/O 操作设置截止时间。</p><p><code>Value</code> 方法允许 <code>Context</code> 对象携带request作用域的数据，该数据必须是线程安全的。</p><h2 id="继承-context">继承 context</h2><p>context 包提供了一些函数，协助用户从现有的 <code>Context</code> 对象创建新的 <code>Context</code> 对象。<br>这些 <code>Context</code> 对象形成一棵树：当一个 <code>Context</code> 对象被取消时，继承自它的所有 <code>Context</code> 都会被取消。</p><p><code>Background</code> 是所有 <code>Context</code> 对象树的根，它不能被取消。它的声明如下：</p><pre><code>// Background returns an empty Context. It is never canceled, has no deadline,
// and has no values. Background is typically used in main, init, and tests,
// and as the top-level `Context` for incoming requests.
func Background() Context
</code></pre><p><code>WithCancel</code> 和 <code>WithTimeout</code> 函数 会返回继承的 <code>Context</code> 对象， 这些对象可以比它们的父 <code>Context</code> 更早地取消。</p><p>当请求处理函数返回时，与该请求关联的 <code>Context</code> 会被取消。 当使用多个副本发送请求时，可以使用 <code>WithCancel</code>取消多余的请求。 <code>WithTimeout</code> 在设置对后端服务器请求截止时间时非常有用。 下面是这三个函数的声明：</p><pre><code>// WithCancel returns a copy of parent whose Done channel is closed as soon as
// parent.Done is closed or cancel is called.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// A CancelFunc cancels a Context.
type CancelFunc func()

// WithTimeout returns a copy of parent whose Done channel is closed as soon as
// parent.Done is closed, cancel is called, or timeout elapses. The new
// Context's Deadline is the sooner of now+timeout and the parent's deadline, if
// any. If the timer is still running, the cancel function releases its
// resources.
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre><p><code>WithValue</code> 函数能够将请求作用域的数据与 <code>Context</code> 对象建立关系。声明如下：</p><pre><code>// WithValue returns a copy of parent whose Value method returns val for key.
func WithValue(parent Context, key interface{}, val interface{}) Context
</code></pre><p>当然，想要知道 <code>Context</code> 包是如何工作的，最好的方法是看一个栗子。</p><h2 id="一个栗子-google-web-search">一个栗子：Google Web Search</h2><p>我们的例子是一个 HTTP 服务，它能够将类似于 <code>/search?q=golang&amp;timeout=1s</code> 的请求 转发给<br><a href="https://developers.google.com/web-search/docs/">Google Web Search API</a>，然后渲染返回的结果。<code>timeout</code> 参数用来告诉 server 时间到时取消请求。</p><p>这个例子的代码存放在三个包里：</p><ol><li><p><a href="https://blog.golang.org/context/server/server.go">server</a>：它提供 main 函数和 处理 <code>/search</code> 的 http handler</p></li><li><p><a href="https://blog.golang.org/context/userip/userip.go">userip</a>：它能够从 请求解析用户的IP，并将请求绑定到一个 <code>Context</code> 对象。</p></li><li><p><a href="https://blog.golang.org/context/google/google.go">google</a>：它包含了 Search 函数，用来向 Google 发送请求。</p></li></ol><h3 id="深入-server-程序">深入 server 程序</h3><p><a href="https://blog.golang.org/context/server/server.go">server</a> 程序处理类似于 <code>/search?q=golang</code> 的请求，返回 Google API 的搜索结果。它将 <code>handleSearch</code> 函数注册到 <code>/search</code> 路由。处理函数创建一个 <code>Context</code> ctx，并对其进行初始化，以保证 <code>Context</code> 取消时，处理函数返回。如果请求的 URL 参数中包含 <code>timeout</code>，那么当 <code>timeout</code> 到期时， <code>Context</code> 会被自动取消。<br>handleSearch 的代码如下：</p><pre><code>func handleSearch(w http.ResponseWriter, req *http.Request) {
    // ctx is the `Context` for this handler. Calling cancel closes the
    // ctx.Done channel, which is the cancellation signal for requests
    // started by this handler.
    var (
        ctx    context.Context
        cancel context.CancelFunc
    )
    timeout, err := time.ParseDuration(req.FormValue(&quot;timeout&quot;))
    if err == nil {
        // The request has a timeout, so create a `Context` that is
        // canceled automatically when the timeout expires.
        ctx, cancel = context.WithTimeout(context.Background(), timeout)
    } else {
        ctx, cancel = context.WithCancel(context.Background())
    }
    defer cancel() // Cancel ctx as soon as handleSearch returns.
</code></pre><p>处理函数 (handleSearch) 将query 参数从请求中解析出来，然后通过 userip 包将client IP解析出来。这里 Client IP 在后端发送请求时要用到，所以 handleSearch 函数将它 attach 到 <code>Context</code> 对象 ctx 上。代码如下：</p><pre><code>// Check the search query.
query := req.FormValue(&quot;q&quot;)
if query == &quot;&quot; {
    http.Error(w, &quot;no query&quot;, http.StatusBadRequest)
    return
}

// Store the user IP in ctx for use by code in other packages.
userIP, err := userip.FromRequest(req)
if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    return
}
ctx = userip.NewContext(ctx, userIP)
</code></pre><p>处理函数带着 <code>Context</code> 对象 <code>ctx</code> 和 <code>query</code> 调用 <code>google.Search</code>，代码如下：</p><pre><code>// Run the Google search and print the results.
start := time.Now()
results, err := google.Search(ctx, query)
elapsed := time.Since(start)
</code></pre><p>如果搜索成功，处理函数会渲染搜索结果，代码如下：</p><pre><code>if err := resultsTemplate.Execute(w, struct {
    Results          google.Results
    Timeout, Elapsed time.Duration
}{
    Results: results,
    Timeout: timeout,
    Elapsed: elapsed,
}); err != nil {
    log.Print(err)
    return
}
</code></pre><h3 id="深入-userip-包">深入 userip 包</h3><p><a href="https://blog.golang.org/context/userip/userip.go">userip</a> 包提供了两个功能：</p><ol><li><p>从请求解析出Client IP；</p></li><li><p>将 Client IP 关联到一个 <code>Context</code> 对象。</p></li></ol><p>一个 <code>Context</code> 对象提供一个 key-value 映射，key 和 value的类型都是 interface{}，但是 key 必须满足等价性（可以比较），value 必须是线程安全的。类似于 <code>userip</code> 的包隐藏了映射的细节，提供的是对特定 <code>Context</code> 类型值得强类型访问。</p><p>为了避免 key 冲突，<code>userip</code> 定义了一个非输出类型 <code>key</code>，并使用该类型的值作为 <code>Context</code> 的key。代码如下：</p><pre><code>// 为了避免与其他包中的 `Context` key 冲突
// 这里不输出 key 类型 (首字母小写)
type key int

// userIPKey 是 user IP 的 `Context` key
// 它的值是随意写的。如果这个包中定义了其他
// `Context` key，这些 key 必须不同
const userIPKey key = 0
</code></pre><p>函数 <code>FromRequest</code> 用来从一个 http.Request 对象中解析出 userIP：</p><pre><code>func FromRequest(req *http.Request) (net.IP, error) {
    ip, _, err := net.SplitHostPort(req.RemoteAddr)
    if err != nil {
        return nil, fmt.Errorf(&quot;userip: %q is not IP:port&quot;, req.RemoteAddr)
    }
</code></pre><p>函数 <code>NewContext</code> 返回一个新的 <code>Context</code> 对象，它携带者 userIP：</p><pre><code>func NewContext(ctx context.Context, userIP net.IP) context.Context {
    return context.WithValue(ctx, userIPKey, userIP)
}
</code></pre><p>函数 <code>FromContext</code> 从一个 <code>Context</code> 对象中解析 userIP：</p><pre><code>func FromContext(ctx context.Context) (net.IP, bool) {
    // ctx.Value returns nil if ctx has no value for the key;
    // the net.IP type assertion returns ok=false for nil.
    userIP, ok := ctx.Value(userIPKey).(net.IP)
    return userIP, ok
}
</code></pre><h3 id="深入-google-包">深入 google 包</h3><p>函数 <code>google.Search</code> 想 Google Web Search API 发送一个 HTTP 请求，并解析返回的 JSON 数据。该函数接收一个 <code>Context</code> 对象 ctx 作为第一参数，在请求还没有返回时，一旦 <code>ctx.Done</code> 关闭，该函数也会立即返回。</p><p>Google Web Search API 请求包含 query 关键字和 user IP 两个参数。具体实现如下：</p><pre><code>func Search(ctx context.Context, query string) (Results, error) {
    // Prepare the Google Search API request.
    req, err := http.NewRequest(&quot;GET&quot;, &quot;https://ajax.googleapis.com/ajax/services/search/web?v=1.0&quot;, nil)
    if err != nil {
        return nil, err
    }
    q := req.URL.Query()
    q.Set(&quot;q&quot;, query)

    // If ctx is carrying the user IP address, forward it to the server.
    // Google APIs use the user IP to distinguish server-initiated requests
    // from end-user requests.
    if userIP, ok := userip.FromContext(ctx); ok {
        q.Set(&quot;userip&quot;, userIP.String())
    }
    req.URL.RawQuery = q.Encode()
</code></pre><p>函数 <code>Search</code> 使用一个辅助函数 <code>httpDo</code> 发送 HTTP 请求，并在 <code>ctx.Done</code> 关闭时取消请求 (如果还在处理请求或返回)。函数 <code>Search</code> 传递给 <code>httpDo</code> 一个闭包处理 HTTP 结果。下面是具体实现：</p><pre><code>var results Results
err = httpDo(ctx, req, func(resp *http.Response, err error) error {
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    // Parse the JSON search result.
    // https://developers.google.com/web-search/docs/#fonje
    var data struct {
        ResponseData struct {
            Results []struct {
                TitleNoFormatting string
                URL               string
            }
        }
    }
    if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {
        return err
    }
    for _, res := range data.ResponseData.Results {
        results = append(results, Result{Title: res.TitleNoFormatting, URL: res.URL})
    }
    return nil
})
// httpDo waits for the closure we provided to return, so it's safe to
// read results here.
return results, err
</code></pre><p>函数 <code>httpDo</code> 在一个新的 goroutine 中发送 HTTP 请求和处理结果。如果 <code>ctx.Done</code> 已经关闭，而处理请求的 goroutine 还存在，那么取消请求。下面是具体实现：</p><pre><code>func httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {
    // Run the HTTP request in a goroutine and pass the response to f.
    tr := &amp;http.Transport{}
    client := &amp;http.Client{Transport: tr}
    c := make(chan error, 1)
    go func() { c &lt;- f(client.Do(req)) }()
    select {
    case &lt;-ctx.Done():
        tr.CancelRequest(req)
        &lt;-c // Wait for f to return.
        return ctx.Err()
    case err := &lt;-c:
        return err
    }
}
</code></pre><h2 id="在自己的代码中使用-context">在自己的代码中使用 <code>Context</code></h2><p>许多服务器框架都提供了管理请求作用域数据的包和类型。我们可以定义一个 <code>Context</code> 接口的实现，<br>将已有代码和期望 <code>Context</code> 参数的代码粘合起来。</p><p>举个栗子，Gorilla 框架的 <a href="http://www.gorillatoolkit.org/pkg/context">github.com/gorilla/context</a> 包允许处理函数 (handlers) 将数据和请求结合起来，他通过 HTTP 请求 到 key-value对 的映射来实现。在 <a href="https://blog.golang.org/context/gorilla/gorilla.go">gorilla.go</a> 中，我们提供了一个 <code>Context</code> 的具体实现，这个实现的 Value 方法返回的值已经与 gorilla 包中特定的 HTTP 请求关联起来。</p><p>还有一些包实现了类似于 <code>Context</code> 的取消机制。比如 <a href="http://godoc.org/gopkg.in/tomb.v2">Tomb</a> 中有一个 Kill 方法，该方法通过关闭 名为<code>Dying</code> 的 channel 发送取消信号。<code>Tomb</code> 也提供了等待 goroutine 退出的方法，类似于 <code>sync.WaitGroup</code>。在 <a href="https://blog.golang.org/context/tomb/tomb.go">tomb.go</a> 中，我们提供了一个 <code>Context</code> 的实现，当它的父 <code>Context</code> 被取消<br>或 一个 <code>Tomb</code> 对象被 kill 时，该 <code>Context</code> 对象也会被取消。</p><h2 id="结论">结论</h2><p>在 Google， 我们要求 Go 程序员把 <code>Context</code> 作为第一个参数传递给 入口请求和出口请求链路上的每一个函数。这种机制一方面保证了多个团队开发的 Go 项目能够良好地协作，另一方面它是一种简单的超时和取消机制，保证了临界区数据 (比如安全凭证) 在不同的 Go 项目中顺利传递。</p><p>如果你要在 <code>Context</code> 之上构建服务器框架，需要一个自己的 <code>Context</code> 实现，在框架与期望 <code>Context</code> 参数的代码之间建立一座桥梁。<br>当然，Client 库也需要接收一个 <code>Context</code> 对象。在请求作用域数据与取消之间建立了通用的接口以后，开发者使用 Context<br>分享代码、创建可扩展的服务都会非常方便。</p><p>原作者：Sameer Ajmani 翻译：Oscar</p><p>下期预告：Go语言并发模型：使用 select (<a href="https://talks.golang.org/2012/concurrency.slide#31">原文链接</a>)。</p><h2 id="相关链接">相关链接</h2><ol><li><p><a href="https://blog.golang.org/context">原文链接</a></p></li><li><p><a href="https://blog.golang.org/context/">代码位置</a></p></li><li><p><a href="https://github.com/oscarzhao/golang/tree/master/go_blog">代码位置(mirror)</a></p></li><li><p><a href="https://github.com/golang/net">mirror of package net</a></p></li><li><p><a href="https://developers.google.com/web-search/docs/">Google Web Search API</a></p></li></ol><hr><p>扫码关注微信公众号“深入Go语言”</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/context.html">context</a> <a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/golang-xian-su-qi.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">Golang限速器</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/golangxue-xi-bi-ji----biao-zhun-ku-ampquotnet_httpampquotde-jian-xi-ji-zi-zhi-jian-chan-lu-you-kuang-j.html"><span class="next-text nav-default">Golang学习笔记-标准库&amp;amp;quot;net_http&amp;amp;quot;的简析及自制简单路由框架</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>