<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>创建尽可能小的Docker容器 - 虞双齐爱折腾</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="注：本文由 Adriaan de Jonge 编写，本文的原文地址为 Create The Smallest Possible Docker Container 当我们在使用 Docker 的时候，你会很快注意到你正在下载很多 MB 作为你的预先配置的容器。一个简单的 Ubuntu 容"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/chuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="创建尽可能小的Docker容器"><meta property="og:description" content="注：本文由 Adriaan de Jonge 编写，本文的原文地址为 Create The Smallest Possible Docker Container 当我们在使用 Docker 的时候，你会很快注意到你正在下载很多 MB 作为你的预先配置的容器。一个简单的 Ubuntu 容"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/chuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html"><meta property="article:published_time" content="2016-12-31T11:34:48&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:34:48&#43;08:00"><meta itemprop="name" content="创建尽可能小的Docker容器"><meta itemprop="description" content="注：本文由 Adriaan de Jonge 编写，本文的原文地址为 Create The Smallest Possible Docker Container 当我们在使用 Docker 的时候，你会很快注意到你正在下载很多 MB 作为你的预先配置的容器。一个简单的 Ubuntu 容"><meta itemprop="datePublished" content="2016-12-31T11:34:48&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:34:48&#43;08:00"><meta itemprop="wordCount" content="2624"><meta itemprop="keywords" content="golang,dockerfile,docker,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="创建尽可能小的Docker容器"><meta name="twitter:description" content="注：本文由 Adriaan de Jonge 编写，本文的原文地址为 Create The Smallest Possible Docker Container 当我们在使用 Docker 的时候，你会很快注意到你正在下载很多 MB 作为你的预先配置的容器。一个简单的 Ubuntu 容"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐爱折腾</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐爱折腾</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">创建尽可能小的Docker容器</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 2624 字 </span><span class="more-meta">预计阅读 6 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><a href="#为-scratch-镜像创建内容">为 scratch 镜像创建内容</a></li><li><a href="#从-docker-内部调用-docker">从 Docker 内部调用 Docker</a></li><li><a href="#创建在-go-中的可执行静态链接">创建在 Go 中的可执行静态链接</a></li><li><a href="#创建一个-docker-容器来创建一个-docker-容器">创建一个 Docker 容器来创建一个 Docker 容器</a></li></ul></nav></div></div><div class="post-content"><blockquote><p>注：本文由 <a href="http://blog.xebia.com/2014/07/04/create-the-smallest-possible-docker-container/#">Adriaan de Jonge</a> 编写，本文的原文地址为 <a href="http://blog.xebia.com/2014/07/04/create-the-smallest-possible-docker-container/">Create The Smallest Possible Docker Container</a></p></blockquote><p>当我们在使用 Docker 的时候，你会很快注意到你正在下载很多 MB 作为你的预先配置的容器。一个简单的 Ubuntu 容器很容易超过 200 MB，并且随着在上面安装软件，尺寸在逐渐增大。在某些情况下，你不需要任何事情都使用 Ubuntu 。例如，如果你只是简单的想运行一个 web 服务，使用 GO 编写的，没有必要围绕它使用任何工具。</p><p>我一直在寻找尽可能小的容器入手，并且发现了一个：</p><pre><code>docker pull scratch
</code></pre><p>scratch 镜像是完美的，真正的完美！它简洁，小巧以及快速。它不包含任何 bug，安全泄漏，慢的代码或是技术债务。这是因为它是一个空的镜像。除了一点由 Docker 加入的元数据。事实上，你可以使用如下命令按照 <a href="https://docs.docker.com/articles/baseimages/#creating-a-simple-base-image-using-scratch">Docker 文档</a>描述的那样创建一个自己的 scratch 镜像。</p><pre><code>tar cv --files-from /dev/null | docker import - scratch
</code></pre><p>所以这可能就是最小的 Docker 镜像。</p><p>或者我们可以说说关于这个的更多东西？比如，你怎样使用 scratch 镜像。这给自己带来了一些挑战。</p><h1 id="为-scratch-镜像创建内容">为 scratch 镜像创建内容</h1><p>我们可以在一个空镜像中运行什么？一个没有依赖的可执行程序。你是否有没有依赖的可执行程序？</p><p>我过去常常使用 Python，Java 和 Javascript 编写代码。每一个这样的语言/平台都需要一个运行时的安装。最近，我开始涉及 Go（或是 golang 如果你喜欢）平台。看起来 Go 是静态连接的。因此我尝试编译一个简单的 web 服务输出 Hello World 并且运行在 scratch 容器中。下面是这个 Hello World web 服务的代码：</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, &quot;Hello World from Go in minimal Docker container&quot;)
}

func main() {
    http.HandleFunc(&quot;/&quot;, helloHandler)

    fmt.Println(&quot;Started, serving at 8080&quot;)
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    if err != nil {
        panic(&quot;ListenAndServe: &quot; + err.Error())
    }
}
</code></pre><p>明显地，我不能在 scratch 容器中编译我的 web 服务，因为容器中没有 Go 编译器。正如我在 Mac 上工作，我也无法编译 Linux 的二进制文件一样（实际上，是可以在不同的平台上交叉编译 Go 的源码的，但这会在另外一篇博客中介绍）。</p><p>因此，我首先需要一个有 Go 编译器的 Docker 容器。让我们开始：</p><pre><code>docker run -ti google/golang /bin/bash
</code></pre><p>在这个容器里面，我可以构建一个 Web 服务，通过我已经提交到<a href="https://github.com/adriaandejonge/helloworld">一个 GitHub 仓库</a>的代码。</p><pre><code>go get github.com/adriaandejonge/helloworld
</code></pre><p>go get 命令是 go build 命令的变种，运行获取和构建远程的依赖。你可以运行可执行的结果：</p><pre><code>$GOPATH/bin/helloworld
</code></pre><p>它工作了，但是这不是我们想要的。我们需要 hello world 容器运行在 scratch 容器里面。因此，实际上，我们需要一个 Dockerfile :</p><pre><code>FROM scratch
ADD bin/helloworld /helloworld
CMD [&quot;/helloworld&quot;]
</code></pre><p>然后启动它，不幸的是，我们开始 google/golang 容器的这个方法， 没有办法构建这个 Dockerfile 。因此，首先，我们需要一种方法从这个容器内部访问到 Docker。</p><h1 id="从-docker-内部调用-docker">从 Docker 内部调用 Docker</h1><p>当你使用 Dokcer 时，你迟早会遇到需要从 Docker 内部访问 Docker。可以有多种方法实现它。你可以使用递归和<a href="https://github.com/jpetazzo/dind">在 Docker 中运行 Docker</a>。尽管如此，这样看起来会很复杂并且导致容器很大。你还可以使用一些额外的命令选项在实例外访问 Docker 服务器：</p><pre><code>docker run -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) -ti google/golang /bin/bash
</code></pre><p>在你继续前，你重新运行 Go 编译器，由于在重启动过程中 Docker 忘记了我们以前编译过。</p><pre><code>go get github.com/adriaandejonge/helloworld
</code></pre><p>当我们启动这个容器， <code>-v</code> 参数在 Docker 容器中创建一个卷并且允许你从 Docker 的机器提供一个文件作为输入。<code>/var/run/docker.sock</code> 是 UNIX socket，通过这个允许你访问 Docker 服务。 <code>(which docker)</code> 部分是一个非常聪明的方法，它提供了一个在 容器中的 Docker 可执行文件的路径，而不是硬编码。尽管如此，当你在 Mac 上通过 boot2docker 使用这个命令的时候需要小心。如果 Docker 的可执行文件与 boot2docker 虚拟机的在不同的位置，将导致不匹配。因此，你或许想使用 <code>/usr/local/bin/docker</code> 硬编码的方式替换 <code>$(which docker)</code>，如果你运行在不同的系统，<code>/var/run/docker.sock</code> 有在不同位置的机会，你需要做相应的调整。</p><p>现在你可以在 google/golang 容器的 \$GOPATH 目录使用 Dockerfile ，在这个示例中指向 <code>/gopath</code>。实际上，我已经在 github 上检查过了这个 <code>Dockerfile</code>，因此，你可以从 Go build 目录复制它到所需的位置，像这样：</p><pre><code>cp $GOPATH/src/github.com/adriaandejonge/helloworld/Dockerfile $GOPATH
</code></pre><p>你需要复制这个作为二进制的编译文件，现在位于 \$GOPATH/bin，并且它不可能从父目录包含文件当构建一个 Dockerfile 的时候。因此复制后，下一步是：</p><pre><code>docker build -t adejonge/helloworld $GOPATH
</code></pre><p>所有的都完成以后， Docker 给出如下响应：</p><pre><code>Successfully built 6ff3fd5a381d
</code></pre><p>允许你运行这个容器：</p><pre><code>docker run -ti --name hellobroken adejonge/helloworld
</code></pre><p>但是不幸的是， Docker 这次响应如下：</p><pre><code>2014/07/02 17:06:48 no such file or directory
</code></pre><p>那么到底是怎么回事？我们在 scratch 容器中有可执行的静态链接。难道我们犯了一个错误？</p><p>事实证明，Go 不是静态链接库。或者至少不是所有的库。在 Linux 下，我们可以使用 ldd 命令来看到动态链接库：</p><pre><code>ldd $GOPATH/bin/helloworld 
</code></pre><p>得到如下响应：</p><pre><code>linux-vdso.so.1 =&gt; (0x00007fff039fe000)
libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f61df30f000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f61def84000)
/lib64/ld-linux-x86-64.so.2 (0x00007f61df530000)
</code></pre><p>因此，在我们运行我们的 web 服务之前，我需要告诉 go 编译器实际的静态链接。</p><h1 id="创建在-go-中的可执行静态链接">创建在 Go 中的可执行静态链接</h1><p>为了创建可执行的静态链接，我们需要告诉 Go 使用 cgo 编译器而不是 go 编译器。命令如下：</p><pre><code>CGO_ENABLED=0 go get -a -ldflags '-s' github.com/adriaandejonge/helloworld
</code></pre><p><code>CGO_ENABLED</code> 环境变量告诉 Go 使用 cgo 编译器而不是 go 编译器。<code>-a</code> 参数告诉 GO 重薪构建所有的依赖。否则的话你将以动态链接依赖结束。最后的 <code>-ldflags '-s'</code> 参数是一个非常好的扩展。它大概降低了可执行文件 50% 的文件大小。你也可以不通过 cgo 使用这个。尺寸缩小是去除了调试信息的结果。</p><p>为了确定，运行 ldd 命令：</p><pre><code>ldd $GOPATH/bin/helloworld 
</code></pre><p>返回是：</p><pre><code>not a dynamic executable
</code></pre><p>你也可以重新运行步骤，围绕着从 scratch 创建 Docker 容器的可执行文件。</p><pre><code>docker build -t adejonge/helloworld $GOPATH
</code></pre><p>如果一切顺利，Docker 将响应如下：</p><pre><code>Successfully built 6ff3fd5a381d
</code></pre><p>允许你运行这个容器：</p><pre><code>docker run -ti --name helloworld adejonge/helloworld
</code></pre><p>响应如下：</p><pre><code>Started, serving at 8080
</code></pre><p>到目前为止，有许多手动的步骤和很多错误的地方。让我们退出 google/golang 容器并且从周边服务器继续：</p><pre><code>&lt;Press Ctrl-C&gt;
exit
</code></pre><p>你可以检查 Docker 容器和镜像存在不存在：</p><pre><code>docker ps -a
docker images -a
</code></pre><p>你可以使用如下命令清理：</p><pre><code>docker rm -f helloworld
docker rmi -f adejonge/helloworld
</code></pre><h1 id="创建一个-docker-容器来创建一个-docker-容器">创建一个 Docker 容器来创建一个 Docker 容器</h1><p>目前为止，我们花了那么多步骤，我们还可以记录在 Dockerfile 中并且 Docker 会为我们做这些工作：</p><pre><code>FROM google/golang
RUN CGO_ENABLED=0 go get -a -ldflags '-s' github.com/adriaandejonge/helloworld
RUN cp /gopath/src/github.com/adriaandejonge/helloworld/Dockerfile /gopath
CMD docker build -t adejonge/helloworld gopath
</code></pre><p>我在 <a href="https://github.com/adriaandejonge/hellobuild">一个单独的称为 adriaandejonge/hellobuild 的 GitHub 仓库</a>检查了 Dockerfile。它可以使用下面的命令构建：</p><pre><code>docker build -t adejonge/hellobuild github.com/adriaandejonge/hellobuild
</code></pre><p>提供 <code>-t</code> 参数命名 adejonge/hellobuild 镜像并且它的最新的隐式的标签。这些名字让你以后更容易去除镜像。下一步，你可以使用就像我们在这篇文章前面看到的那样提供一个参数从这个镜像中创建一个容器：</p><pre><code>docker run -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) -ti --name hellobuild adejonge/hellobuild
</code></pre><p>提供 <code>--name hellobuild</code> 参数使得在运行后更容易移除容器。事实上，你可以这样做，因为运行这个命令后，你已经创建了一个 adejonge/helloworld 镜像：</p><pre><code>docker rm -f hellobuild
docker rmi -f adejonge/hellobuild
</code></pre><p>现在你可以创建一个基于 adejonge/helloworld 镜像的名为 helloworld 的新容器，就像你以前做的那样：</p><pre><code>docker run -ti --name helloworld adejonge/helloworld
</code></pre><p>因为所有的这些步骤都是从相同的命令中运行，不需要在 Docker 中打开一个 bash shell 。你可以把这些步骤添加进一个 bash 脚本，自动运行它，为了使你方便，<a href="https://github.com/adriaandejonge/hellobuild/tree/master/scripts">我已经把这些脚本加入了 hellobuild GitHub 仓库</a>。</p><p>另外，如果你想尝试一个尽可能小的容器，但是又不想遵循博客中的步骤，你可以使用我检入进 <a href="https://registry.hub.docker.com/u/adejonge/helloworld/">Docker Hub repository</a> 的预先构建好的镜像。</p><pre><code>docker pull adejonge/helloworld
</code></pre><p>使用 docker images -a ，你可以看到大小是 3.6MB。当然，如果你成功创建一个比我使用 Go 编写的 web 服务还小的可执行文件，你可以使得它更小。使用 C 语言或者是汇编，你可以这样做到。尽管如此，你不可能使得它比 scratch 镜像还小</p><p><strong>扩展阅读</strong></p><ul><li><a href="http://www.centurylinklabs.com/optimizing-docker-images/">OPTIMIZING DOCKER IMAGES</a></li></ul></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a> <a href="/tags/dockerfile.html">dockerfile</a> <a href="/tags/docker.html">docker</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/golangzai-windowsping-tai-shi-yong-zmq.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">golang在windows平台使用zmq</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/go-kai-fa-zhe-dui--go-chu-xue-zhe-de-jian-yi.html"><span class="next-text nav-default">GO开发者对GO初学者的建议</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2018 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/javascript">window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>