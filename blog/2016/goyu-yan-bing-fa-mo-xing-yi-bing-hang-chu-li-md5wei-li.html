<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Go语言并发模型:以并行处理MD5为例 - 虞双齐爱折腾</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。 本文要"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link href="https://cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css" rel="stylesheet" crossorigin="anonymous"><meta property="og:title" content="Go语言并发模型:以并行处理MD5为例"><meta property="og:description" content="简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。 本文要"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html"><meta property="article:published_time" content="2016-12-31T11:33:12&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:33:12&#43;08:00"><meta itemprop="name" content="Go语言并发模型:以并行处理MD5为例"><meta itemprop="description" content="简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。 本文要"><meta itemprop="datePublished" content="2016-12-31T11:33:12&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:33:12&#43;08:00"><meta itemprop="wordCount" content="2334"><meta itemprop="keywords" content="golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go语言并发模型:以并行处理MD5为例"><meta name="twitter:description" content="简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。 本文要"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐爱折腾</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐爱折腾</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Go语言并发模型:以并行处理MD5为例</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 2334 字 </span><span class="more-meta">预计阅读 5 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#简介">简介</a></li><li><a href="#阅读建议">阅读建议</a></li><li><a href="#单线程版的-md5sum">单线程版的 md5sum</a></li><li><a href="#并发版的-md5sum">并发版的 md5sum</a></li><li><a href="#限制并发量">限制并发量</a></li><li><a href="#相关链接">相关链接</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="简介">简介</h2><p>Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。</p><p>本文要讲的就是一些使用流水线的一些例子，流水线的错误处理也是本文的重点。</p><h2 id="阅读建议">阅读建议</h2><p>本文是<a href="https://segmentfault.com/a/1190000006261218">&ldquo;Go语言并发模型：像Unix Pipe那样使用channel&rdquo;</a><br>一文的下半部分，但重点在于实践。如果你对 channel 已经比较熟悉，则可以独立阅读。<br>如果你对 channel 和 go 两个关键字不太熟悉，建议先阅读上半部分。</p><p>本文所使用的例子是批量计算文件的MD5值，实现了 linux 下的 md5sum 命令。<br>我们首先会讲到 md5sum 的单线程版本，逐步深入到并发的初级和高级版本。</p><p>本文中绝大多数讲解都是基于代码进行的。在文章末尾&rdquo;相关链接&rdquo;中可以下载三个版本的 md5sum 的实现。</p><h2 id="单线程版的-md5sum">单线程版的 md5sum</h2><p>MD5 是一种广泛用于文件校验的 hash 算法。Linux 下的 md5sum 命令会打印一组文件的 md5值。它的使用方式如下：</p><pre><code>% md5sum *.go
c33237079343a4d567a2a29df0b8e46e  bounded.go
a7e3771f2ed58d4b34a73566d93ce63a  parallel.go
1dc687202696d650594aaac56d579179  serial.go
</code></pre><p>我们的示例程序类似于 md5sum，但是它接收文件夹作为参数，并打印出每个文件的 md5值，打印结果按照路径排序。<br>下面这个例子是 打印当前目录下所有文件的 md5 值：</p><pre><code>% go run serial.go .
c33237079343a4d567a2a29df0b8e46e  bounded.go
a7e3771f2ed58d4b34a73566d93ce63a  parallel.go
1dc687202696d650594aaac56d579179  serial.go
</code></pre><p>程序的 main 函数调用辅助函数 MD5All，它会返回路径名称到md5值的一个映射。main 函数中对结果进行排序以后，打印出来：</p><pre><code>func main() {
    // 计算特定目录下所有文件的 md5值， 
    // 然后按照路径名顺序打印结果
    m, err := MD5All(os.Args[1])
    if err != nil {
        fmt.Println(err)
        return
    }
    var paths []string
    for path := range m {
        paths = append(paths, path)
    }
    sort.Strings(paths)
    for _, path := range paths {
        fmt.Printf(&quot;%x  %s\n&quot;, m[path], path)
    }
}
</code></pre><p>本文中，函数 MD5All 是讨论的焦点。在 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/serial.go">serial.go</a>的实现中，我们没有使用并发，而是逐个读取和计算 filepath.Walk 生成的目录和文件。代码如下：</p><pre><code>// MD5All 读取 root 目录下的所有文件，返回一个map
// 该 map 存储了 文件路径到文件内容 md5值的映射
// 如果 Walk 执行失败，或者 ioutil.ReadFile 读取失败，
// MD5All 都会返回错误
func MD5All(root string) (map[string][md5.Size]byte, error) {
    m := make(map[string][md5.Size]byte)
    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if !info.Mode().IsRegular() {
            return nil
        }
        data, err := ioutil.ReadFile(path)
        if err != nil {
            return err
        }
        m[path] = md5.Sum(data)
        return nil
    })
    if err != nil {
        return nil, err
    }
    return m, nil
}
</code></pre><p>上面的代码中，<a href="https://golang.org/pkg/path/filepath/#Walk">filepath.Walk</a> 接收两个参数，文件路径和函数指针。<br>只要是函数签名和返回值 满足 <code>func(string, os.FileInfo, error) error</code>，均可以作为第二参数传递给 filepath.Walk。</p><p>点击 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/serial.go">serial.go</a> 下载单线程版本的 md5sum。</p><h2 id="并发版的-md5sum">并发版的 md5sum</h2><p>点击 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/parallel.go">parallel.go</a> 下载并发版 md5sum 的代码。</p><p>在这个版本的实现中，我们把 MD5All 切割成两个阶段的流水线。<br>第一阶段是 sumFiles，它遍历文件树，每个文件都在一个新的 goroutine 里计算md5值，然后将结果发送到一个result 类型的channel里。<br>result 类型的定义如下：</p><pre><code>type result struct {
    path string
    sum  [md5.Size]byte
    err  error
}
</code></pre><p>sumFiles 返回两个 channel，一个用于接收 md5计算的结果，一个用于接收 filepath.Walk 产生的错误。<br>Walk 函数为每一个文件创建一个 goroutine，然后检查 done channel。如果 done channel 被关闭，walk 函数立即停止执行。代码示例如下：</p><pre><code>func sumFiles(done &lt;-chan struct{}, root string) (&lt;-chan result, &lt;-chan error) {
    // 对于每一个普通文件，启动一个 gorotuine 计算文件 md5 值，
    // 然后 将结果发送到 c。
    // walk 的错误结果发送到 errc。
    c := make(chan result)
    errc := make(chan error, 1)
    go func() {
        var wg sync.WaitGroup
        err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            if !info.Mode().IsRegular() {
                return nil
            }
            wg.Add(1)
            go func() {
                data, err := ioutil.ReadFile(path)
                select {
                case c &lt;- result{path, md5.Sum(data), err}:
                case &lt;-done:
                }
                wg.Done()
            }()
            // done channel 关闭时，终止 walk 函数
            select {
            case &lt;-done:
                return errors.New(&quot;walk canceled&quot;)
            default:
                return nil
            }
        })
        // Walk 函数已经返回，所以 所有对 wg.Add 的调用都会结束
        // 启动一个 goroutine， 它会在所有发送都结束时，关闭 c。
        go func() {
            wg.Wait()
            close(c)
        }()
        // 这里不需要 select 语句，应为 errc 是缓冲管道
        errc &lt;- err
    }()
    return c, errc
}
</code></pre><p>MD5All 从 c 接收 md5值。 MD5All 遇到错误时会提前返回，通过 defer 语句关闭 done channel：</p><pre><code>func MD5All(root string) (map[string][md5.Size]byte, error) {
    // MD5All 在函数返回时关闭 done channel
    // 在从 c 和 errc 接收数据前，也可能关闭
    done := make(chan struct{})
    defer close(done)

    c, errc := sumFiles(done, root)

    m := make(map[string][md5.Size]byte)
    for r := range c {
        if r.err != nil {
            return nil, r.err
        }
        m[r.path] = r.sum
    }
    if err := &lt;-errc; err != nil {
        return nil, err
    }
    return m, nil
}
</code></pre><h2 id="限制并发量">限制并发量</h2><p>在 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/parallel.go">并发版 MD5All (parallel.go)</a> 的实现中，<br>我们为每个文件创建了一个 goroutine。如果一个目录中包含很多大文件，可能出现OOM。</p><p>我们对并发读取的文件数目稍作限制，进而限制内存的分配。点击 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/bounded.go">bounded.go</a><br>查看限制并发版本的 md5sum。 为了实现限制的目的，我们创建固定数量的 goroutine 用于读取文件。<br>这里的流水线包含三个阶段：遍历文件和目录、读取并计算md5值、搜集和整合计算结果。</p><p>第一阶段时 walkFiles，它生成一个目录下每个普通文件的路径。代码如下：</p><pre><code>func walkFiles(done &lt;-chan struct{}, root string) (&lt;-chan string, &lt;-chan error) {
    paths := make(chan string)
    errc := make(chan error, 1)
    go func() {
        // Walk 函数返回时，关闭 channel paths
        defer close(paths)
        // 这里不需要select，因为 errc 是缓冲 channel
        errc &lt;- filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            if !info.Mode().IsRegular() {
                return nil
            }
            select {
            case paths &lt;- path:
            case &lt;-done:
                return errors.New(&quot;walk canceled&quot;)
            }
            return nil
        })
    }()
    return paths, errc
}
</code></pre><p>第二阶段创建固定个数的goroutine digester，每个 digester 从 paths channel 读取文件名，并将结果发送给 c。代码如下：</p><pre><code>func digester(done &lt;-chan struct{}, paths &lt;-chan string, c chan&lt;- result) {
    for path := range paths {
        data, err := ioutil.ReadFile(path)
        select {
        case c &lt;- result{path, md5.Sum(data), err}:
        case &lt;-done:
            return
        }
    }
}
</code></pre><p>不像前面的例子，这里 digester 没有关闭输出 channel c，因为 多个 digester 在共享这个channel。<br>关闭操作放到 MD5All 中实现，当所有 digester 运行结束时，MD5All 关闭这个channel。代码如下：</p><pre><code>    // 启动固定数量的 goroutine 处理文件
    c := make(chan result)
    var wg sync.WaitGroup
    const numDigesters = 20
    wg.Add(numDigesters)
    for i := 0; i &lt; numDigesters; i++ {
        go func() {
            digester(done, paths, c)
            wg.Done()
        }()
    }
    go func() {
        wg.Wait()
        close(c)
    }()
</code></pre><p>我们可以让每个 digester 创建和返回自己的输出 channel。如果这样做，我们还需要额外的 goroutine 去合并结果。</p><p>第三阶段从 channel c 接收结果，并从 channel errc 读取错误信息并执行检查。<br>检查操作不能在 c 读取结束之前完成，因为 walkFiles 函数可能会被阻塞而无法向下游阶段发送数据。 代码如下：</p><pre><code>// ... 省略部分代码 ...
    m := make(map[string][md5.Size]byte)
    for r := range c {
        if r.err != nil {
            return nil, r.err
        }
        m[r.path] = r.sum
    }
    // Check whether the Walk failed.
    if err := &lt;-errc; err != nil {
        return nil, err
    }
    return m, nil
} 
</code></pre><p>关于Go语言并发模型，使用 Go内置的 channel 类型和 go 关键字实现高并发和并发控制的主题就先到这里。<br>在最近发布的 go 1.7中，在核心库中广泛加入了对 context 的支持，以便更好地控制并发和超时。但在这之前<br>golang.org/x/net/context 包就一直存在，下一期我们将对 <a href="https://blog.golang.org/context">context 包</a>及其应用场景进行讨论。</p><h2 id="相关链接">相关链接</h2><ol><li><p><a href="https://blog.golang.org/pipelines">原文链接</a></p></li><li><p><a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/serial.go">serial.go</a></p></li><li><p><a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/parallel.go">parallel.go</a></p></li><li><p><a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/bounded.go">bounded.go</a></p></li><li><p><a href="https://blog.golang.org/context">golang.org/x/net/context</a></p></li></ol><p>扫码关注微信公众号“深入Go语言”</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/goyu-yan-bing-fa-mo-xing-xiang-unix-pipena-yang-shi-yong-channel.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">Go语言并发模型:像UnixPipe那样使用channel</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/golang-zhi--gong-cheng-jie-gou.html"><span class="next-text nav-default">Golang之工程结构</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div id="comments-gitment"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js" crossorigin="anonymous"></script><script type="text/javascript">const gitment = new Gitment({
    id: '转_Go语言并发模型_以并行处理MD5为例.md',
    title: 'Go语言并发模型:以并行处理MD5为例',
    link: decodeURI(location.href),
    desc: '简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I\/O和多核 CPU 的优势。 本文要',
    owner: 'ysqi',
    repo: 'ysqi.github.io',
    oauth: {
      client_id: '639ba986c281b9fcf382',
      client_secret: 'b5862135f283dd308a7f226c06980cf50b8e82f1'
    }
  })
  gitment.render('comments-gitment')</script><noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2018 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js" crossorigin="anonymous"></script><script type="text/javascript" src="https://cdn.bootcss.com/slideout/1.0.1/slideout.min.js" crossorigin="anonymous"></script><script type="text/javascript" src="https://cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/javascript">window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>