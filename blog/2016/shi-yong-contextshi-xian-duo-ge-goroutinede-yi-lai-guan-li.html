<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>使用context实现多个goroutine的依赖管理 - 虞双齐爱折腾</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="解决的问题 在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，比如一个主要的goroutine用来响应请"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/shi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="使用context实现多个goroutine的依赖管理"><meta property="og:description" content="解决的问题 在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，比如一个主要的goroutine用来响应请"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/shi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html"><meta property="article:published_time" content="2016-12-31T11:32:52&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:32:52&#43;08:00"><meta itemprop="name" content="使用context实现多个goroutine的依赖管理"><meta itemprop="description" content="解决的问题 在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，比如一个主要的goroutine用来响应请"><meta itemprop="datePublished" content="2016-12-31T11:32:52&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:32:52&#43;08:00"><meta itemprop="wordCount" content="2535"><meta itemprop="keywords" content="golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用context实现多个goroutine的依赖管理"><meta name="twitter:description" content="解决的问题 在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，比如一个主要的goroutine用来响应请"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐爱折腾</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐爱折腾</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">使用context实现多个goroutine的依赖管理</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 2535 字 </span><span class="more-meta">预计阅读 6 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#解决的问题">解决的问题</a></li><li><a href="#context">context</a></li><li><a href="#如何使用">如何使用</a></li><li><a href="#具体例子">具体例子</a><ul><li><a href="#mycontext-serve-go">mycontext/serve.go</a></li><li><a href="#mycontext-google-google-go">mycontext/google/google.go</a></li><li><a href="#mycontext-query-query-go">mycontext/query/query.go</a></li><li><a href="#mycontext-fakesrv-main-go">mycontext/fakesrv/main.go</a></li><li><a href="#makefile">Makefile</a></li><li><a href="#测试">测试</a></li></ul></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="解决的问题">解决的问题</h2><p>在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，比如一个主要的goroutine用来响应请求，生成网页，同时它还启动一个子线程用来获取数据库信息，还有一个则写日志等等。正常情况都没有问题，但是一旦出现异常，如何优雅的退出这些子线程，同时释放掉可能占用的资源呢？</p><h2 id="context">context</h2><p>在golang中，人们发明了context接口处理这种情况。早在14年，这个库就出现了，并且提出了<a href="https://blog.golang.org/context">基于context的并发编程范式</a>（英文好的同学可以直接撸这篇文章）。<br>今年8月<a href="https://golang.org/doc/go1.7">go1.7</a>发布后，它正式成为了标准库的一员。</p><h2 id="如何使用">如何使用</h2><p>在golang的context库中，首先定义了context的接口，然后给出了context接口的4种实现：</p><ul><li><p>WithCancel(parent Context) (Context, CancelFunc)<br>初始化一个可以被cancel的context，同时把新context对象作为child放入parent的children数组中。当parent终止时，child也会接受到信号。这个过程叫<code>propagateCancel</code></p></li><li><p>WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)<br>同样初始化一个context，除了实现跟<code>WithCancel</code>同样的功能外，还增加了一个时间变量，一旦当前时间超过这个deadline，那么这个context以及它的所有子孙都被被cancel。</p></li><li><p>WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)<br>跟<code>WithDeadline</code>类似，如果说<code>WithDeadline</code>是一个绝对时间上的限制，那么<code>WithTimeout</code>就是一个相对时间的限制</p></li><li><p>WithValue(parent Context, key, val interface{}) Context<br>单纯给parent增加value，不需要<code>propagateCancel</code>。value可以用来跨进程、跨api的传递数据，最好是和某个请求相关的参数，不要传递太多大量数据。</p></li></ul><p>所以关键就在于<code>propagateCancel</code>，实际工程中，所有context共同组成了一个依赖树，他们都继承自一个祖先。一旦parent被cancel，就会通过<code>propagateCancel</code>递归的传播给下面的所有子孙。可以看出，context就好比信使，或者说通讯协议，通过遵循context接口构建的这个框架，能够保证子线程及时获得与他相关的父线程的状态，从而由子线程根据情况作出反应。至于怎么反应，就取决于各位码农的能力和搬砖当时的心情了。。。</p><p>另外，golang有一套静态分析工具可以分析context的传播过程，所以为了方便这个工具的使用，实际使用中有几个规定：</p><ul><li><p>不要把context作为struct内部变量使用，而是把它和其他变量一块作为参数传入下一个函数。</p></li><li><p>context变量需要作为函数的第一个参数传入，命名一般为<code>ctx</code></p></li></ul><h2 id="具体例子">具体例子</h2><p>这个例子来源于<a href="https://blog.golang.org/context">基于context的并发编程范式</a>，但是为了符合国情我做了些修改：<br>包括3部分：</p><ul><li><p>server.go<br>主线程，会创建一个server服务器，可以通过<code>localhost:9090/search</code>访问。接到请求后，它会创建父context，同时生成一个新goroutine，去fakesrv（本来应该去google上的）上请求数据。</p></li><li><p>google.go<br>替换原来的google网址，改成由fakesrv提供的一个网址。主要就是演示一下context的运行过程，请求fakesrv的工作在一个新goroutine中进行，同时它还有一个访问数据库的操作。如果父context因为timeout超时了，那么对fakesrv和数据库的访问也会终止。在代码中，演示了如何监听context信息的过程。</p></li><li><p>query.go<br>解析url中的query参数</p></li><li><p>fakesrv.go<br>提供<a href="http://localhost:9000/context_demo">http://localhost:9000/context&hellip;</a>供google.go访问。</p></li></ul><h3 id="mycontext-serve-go">mycontext/serve.go</h3><pre><code>// The server program issues Google search requests and demonstrates the use of
// the go.net Context API. It serves on port 8080.
//
// The /search endpoint accepts these query params:
//   q=the Google search query
//   timeout=a timeout for the request, in time.Duration format
//
// For example, http://localhost:8080/search?q=golang&amp;timeout=1s serves the
// first few Google search results for &quot;golang&quot; or a &quot;deadline exceeded&quot; error
// if the timeout expires.
package main

import (
    &quot;html/template&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;time&quot;

    &quot;context&quot;
    &quot;mycontext/google&quot;
    &quot;mycontext/query&quot;
)

func main() {
    http.HandleFunc(&quot;/search&quot;, handleSearch)
    log.Fatal(http.ListenAndServe(&quot;:9090&quot;, nil))
}

// handleSearch handles URLs like /search?q=golang&amp;timeout=1s by forwarding the
// query to google.Search. If the query param includes timeout, the search is
// canceled after that duration elapses.
func handleSearch(w http.ResponseWriter, req *http.Request) {
    // ctx is the Context for this handler. Calling cancel closes the
    // ctx.Done channel, which is the cancellation signal for requests
    // started by this handler.
    var (
        ctx    context.Context
        qctx   *query.QueryCtx
        cancel context.CancelFunc
    )
    timeout, err := time.ParseDuration(req.FormValue(&quot;timeout&quot;))
    if err == nil {
        // The request has a timeout, so create a context that is
        // canceled automatically when the timeout expires.
        ctx, cancel = context.WithTimeout(context.Background(), timeout)
    } else {
        ctx, cancel = context.WithCancel(context.Background())
    }
    defer cancel() // Cancel ctx as soon as handleSearch returns.
    qctx, err = query.NewQueryCtx(ctx, req)
    if err != nil {
        http.Error(w, &quot;no query&quot;, http.StatusBadRequest)
        return
    }

    // Run the Google search and print the results.
    start := time.Now()
    results, err := google.Search(qctx)
    elapsed := time.Since(start)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    if err := resultsTemplate.Execute(w, struct {
        Results          google.Results
        Timeout, Elapsed time.Duration
    }{
        Results: results,
        Timeout: timeout,
        Elapsed: elapsed,
    }); err != nil {
        log.Print(err)
        return
    }
}

var resultsTemplate = template.Must(template.New(&quot;results&quot;).Parse(`
&lt;html&gt;
&lt;head/&gt;
&lt;body&gt;
  &lt;ol&gt;
  {{range .Results}}
    &lt;li&gt;{{.Title}} - &lt;span&gt;{{.SubTitle}}&lt;/span&gt;&lt;/li&gt;
  {{end}}
  &lt;/ol&gt;
  &lt;p&gt;{{len .Results}} results in {{.Elapsed}}; timeout {{.Timeout}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
`))
</code></pre><h3 id="mycontext-google-google-go">mycontext/google/google.go</h3><pre><code>// Package google provides a function to do Google searches using the Google Web
// Search API. See https://developers.google.com/web-search/docs/
//
// This package is an example to accompany https://blog.golang.org/context.
// It is not intended for use by others.
//
// Google has since disabled its search API,
// and so this package is no longer useful.
package google

import (
    &quot;context&quot;
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;mycontext/query&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

// Results is an ordered list of search results.
type Results []Result

// A Result contains the title and URL of a search result.
type Result struct {
    Title, SubTitle string
}

// Search sends query to Google search and returns the results.
func Search(ctx *query.QueryCtx) (Results, error) {
    // Prepare the Google Search API request.
    req, err := http.NewRequest(&quot;GET&quot;, &quot;http://localhost:9000/context_demo&quot;, nil)
    if err != nil {
        return nil, err
    }

    ctx.SetReq(req)
    // Issue the HTTP request and handle the response. The httpDo function
    // cancels the request if ctx.Done is closed.
    var results Results
    err = httpDo(ctx, req, func(resp *http.Response, err error) error {
        if err != nil {
            return err
        }
        defer resp.Body.Close()

        // Parse the JSON search result.
        // https://developers.google.com/web-search/docs/#fonje
        var data struct {
            ResponseData struct {
                Results []struct {
                    Title, SubTitle string
                }
            }
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {
            return err
        }
        for _, res := range data.ResponseData.Results {
            results = append(results, Result{Title: res.Title, SubTitle: res.SubTitle})
        }
        return nil
    })
    // httpDo waits for the closure we provided to return, so it's safe to
    // read results here.
    return results, err
}

// httpDo issues the HTTP request and calls f with the response. If ctx.Done is
// closed while the request or f is running, httpDo cancels the request, waits
// for f to exit, and returns ctx.Err. Otherwise, httpDo returns f's error.
func httpDo(ctx *query.QueryCtx, req *http.Request, f func(*http.Response, error) error) error {
    // Run the HTTP request in a goroutine and pass the response to f.
    tr := &amp;http.Transport{}
    client := &amp;http.Client{Transport: tr}
    // WithCancel会在ctx的children中增加cancelDb，这样当
    // ctx 结束的时候，cancelDb也会受到消息
    cancelDb, cancel := context.WithCancel(ctx.Context)
    defer cancel()
    c := make(chan error, 1)
    go func() { c &lt;- f(client.Do(req)) }()
    go func(ctx context.Context) {
        t := time.NewTimer(2 * time.Second)

        select {
        case &lt;-t.C:
            log.Println(&quot;db access finished!&quot;)
        case &lt;-ctx.Done():
            log.Println(&quot;canceld by parent, release resource&quot;)
        }
    }(cancelDb)
    select {
    case &lt;-ctx.Done():
        tr.CancelRequest(req)
        &lt;-c // Wait for f to return.
        return ctx.Err()
    case err := &lt;-c:
        return err
    }
}
</code></pre><h3 id="mycontext-query-query-go">mycontext/query/query.go</h3><pre><code>package query

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func NewQueryCtx(ctx context.Context, req *http.Request) (*QueryCtx, error) {
    q := req.FormValue(&quot;q&quot;)
    if q == &quot;&quot; {
        return nil, fmt.Errorf(&quot;no query supplied!&quot;)
    }
    return &amp;QueryCtx{ctx, q}, nil
}

type QueryCtx struct {
    context.Context
    val string
}

func (ctx *QueryCtx) SetReq(req *http.Request) {
    q := req.URL.Query()
    q.Set(&quot;q&quot;, ctx.val)

    req.URL.RawQuery = q.Encode()
}
</code></pre><h3 id="mycontext-fakesrv-main-go">mycontext/fakesrv/main.go</h3><pre><code>package main

import (
    &quot;bytes&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;math/rand&quot;
    &quot;net/http&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

func init() {
    log.SetFlags(log.Lshortfile)
}

type Results struct {
    ResponseData struct {
        Results []Content
    }
}

// A Result contains the title and URL of a search result.
type Content struct {
    Title, SubTitle string
}

func main() {

    http.HandleFunc(&quot;/context_demo&quot;, handleContext)
    http.ListenAndServe(&quot;:9000&quot;, nil)
}

func handleContext(resp http.ResponseWriter, req *http.Request) {
    defer func() {
        if e := recover(); e != nil {
            if msg, ok := e.(string); ok {
                resp.Write([]byte(msg))
            } else {
                panic(e)
            }
        }
    }()
    check_error := func(err error, msg string) {
        if err != nil {
            if msg != &quot;&quot; {
                panic(err.Error() + &quot;:&quot; + msg)
            } else {
                panic(err.Error())
            }
        }
    }
    if req.Method == &quot;GET&quot; {
        q := req.FormValue(&quot;q&quot;)
        seg := strings.Split(q, &quot;:&quot;)
        if len(seg) &lt; 2 {
            log.Println(&quot;query format wrong&quot;)
            resp.Write([]byte(&quot;query format wrong&quot;))
            return
        }
        title := seg[0]
        num, err := strconv.Atoi(seg[1])
        check_error(err, &quot;&quot;)
        rs := Results{}
        for i := 0; i &lt; num; i++ {
            rs.ResponseData.Results = append(rs.ResponseData.Results,
                Content{fmt.Sprintf(&quot;%s %d&quot;, title, i), RandomString(20)})
        }
        buff := bytes.NewBuffer(nil)
        err = json.NewEncoder(buff).Encode(rs)
        check_error(err, &quot;&quot;)
        time.Sleep(time.Second * 2)
        resp.Write(buff.Bytes())
    } else {
        resp.Write([]byte(&quot;请使用get方法!&quot;))
    }
}
func RandomString(strlen int) string {
    rand.Seed(time.Now().UTC().UnixNano())
    const chars = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;
    result := make([]byte, strlen)
    for i := 0; i &lt; strlen; i++ {
        result[i] = chars[rand.Intn(len(chars))]
    }
    return string(result)
}
</code></pre><h3 id="makefile">Makefile</h3><pre><code>run:
    go build 
    ./mycontext &amp;
    cd fakesrv &amp;&amp; go build &amp;&amp; ./fakesrv &amp;

test:
    @echo &quot;======= test without timeout =======&quot;
    curl localhost:9090/search?q=title:6
    @echo &quot;======= test with timeout 1s =======&quot;
    curl localhost:9090/search?q=title:6\&amp;timeout=1s
    @echo &quot;======= test with timeout 4s =======&quot;
    curl localhost:9090/search?q=title:6\&amp;timeout=4s
</code></pre><h3 id="测试">测试</h3><p>在命令行运行如下命令，即可看到具体结果<br>make run<br>make test</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/_gozk_zookeeper_zk_go-fatal-error-zookeeper_h-file-not-found.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">_gozk_zookeeper_zk_gofatalerror:zookeeper_hfilenotfound</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/zai-beegozhong-shi-yong-jademo-ban.html"><span class="next-text nav-default">在Beego中使用Jade模板</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2018 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="www.miitbeian.gov.cn">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>