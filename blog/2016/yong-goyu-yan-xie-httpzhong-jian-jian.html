<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>用Go语言写HTTP中间件 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通常是一种不太受欢迎的概念。但我认为它棒极"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/yong-goyu-yan-xie-httpzhong-jian-jian.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="用Go语言写HTTP中间件"><meta property="og:description" content="在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通常是一种不太受欢迎的概念。但我认为它棒极"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/yong-goyu-yan-xie-httpzhong-jian-jian.html"><meta property="article:published_time" content="2016-12-31T11:35:10&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:35:10&#43;08:00"><meta itemprop="name" content="用Go语言写HTTP中间件"><meta itemprop="description" content="在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通常是一种不太受欢迎的概念。但我认为它棒极"><meta itemprop="datePublished" content="2016-12-31T11:35:10&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:35:10&#43;08:00"><meta itemprop="wordCount" content="3493"><meta itemprop="keywords" content="http,golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="用Go语言写HTTP中间件"><meta name="twitter:description" content="在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通常是一种不太受欢迎的概念。但我认为它棒极"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">用Go语言写HTTP中间件</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 3493 字 </span><span class="more-meta">预计阅读 7 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><ul><li><a href="#写一个简单的中间件">写一个简单的中间件</a></li><li><a href="#定义类型">定义类型</a></li><li><a href="#处理请求">处理请求</a></li><li><a href="#另外一种方法">另外一种方法</a></li><li><a href="#更复杂的情况">更复杂的情况</a></li><li><a href="#添加数据比较容易">添加数据比较容易</a></li><li><a href="#问题是">问题是</a></li><li><a href="#和其他handlers共享数据">和其他handlers共享数据</a></li><li><a href="#总结">总结</a></li></ul></li></ul></li></ul></nav></div></div><div class="post-content"><p>在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通常是一种不太受欢迎的概念。但我认为它棒极了。</p><p>其一，一个好的中间件拥有单一的功能，可插拔并且是自我约束的。这就意味着你可以在接口的层次上把它放到应用中，并能很好的工作。中间件并不影响你的代码风格，它也不是一个框架，仅仅是你处理请求流程中额外一层罢了。根本不需要重写代码：如果你想用一个中间件，就把它加上应用中；如果你改变主意了，去掉就好了。就这么简单。</p><p>来看看Go，HTTP中间件非常流行，标准库中也是这样。或许咋看上去并不明显，net/http包中的函数，如<a href="http://golang.org/pkg/net/http/#StripPrefix">StripPrefix</a> 和<a href="http://golang.org/pkg/net/http/#TimeoutHandler">TimeoutHandler</a> 正是我们上面定义的中间件：封装处理过程并在处理输入或输出时增加额外的动作。</p><p>我最近的Go包 <a href="https://github.com/justinas/nosurf">nosurf</a> 也是一个中间件。我从一开始就有意的这样设计。大多数情况下，你根本不必在应用层关心CSRF检查。nosurf，和其他中间件一样，非常独立，可以和实现标准库net/http接口的工具配合使用。</p><p>你也可以使用中间件做这些：<br>* 通过隐藏长度缓解BREACH攻击<br>* 频率限制<br>* 屏蔽恶意自动程序<br>* 提供调试信息<br>* 添加HSTS, X-Frame-Options头<br>* 从异常中优雅恢复<br>* 以及其他等等。</p><h3 id="写一个简单的中间件">写一个简单的中间件</h3><p>第一个例子中，我写了一个中间件，只允许用户从特定的域（在HTTP的Host头中有域信息）来访问服务器。这样的中间件可以保护应用程序不受“<a href="http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html">主机欺骗攻击</a>”</p><h3 id="定义类型">定义类型</h3><p>为了方便，让我们为这个中间件定义一种类型，叫做SingleHost。</p><pre><code>type SingleHost struct {

    handler     http.Handler

    allowedHost string

}
</code></pre><p>只包含两个字段：<br>* 封装的Handler。如果是有效的Host访问，我们就调用这个Handler。<br>* 允许的主机值。<br>由于我们把字段名小写了，使得该字段只对我们自己的包可见。我们还应该写一个初始化函数。</p><pre><code>func NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {

    return &amp;SingleHost{handler: handler, allowedHost: allowedHost}

}
</code></pre><h3 id="处理请求">处理请求</h3><p>现在才是实际的逻辑。为了实现http.Handler，我们的类型秩序实现一个方法：</p><pre><code>type Handler interface {

        ServeHTTP(ResponseWriter, *Request)

}
</code></pre><p>这就是我们实现的方法：</p><pre><code>func (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {

    host := r.Host

    if host == s.allowedHost {

        s.handler.ServeHTTP(w, r)

    } else {

        w.WriteHeader(403)

    }

}
</code></pre><p>ServeHTTP 函数仅仅检查请求中的Host头：</p><ul><li>如果Host头匹配初始化函数设置的allowedHost ，就调用封装handler的ServeHTTP方法。</li><li>如果Host头不匹配，就返回403状态码（禁止访问）。</li></ul><p>在后一种情况中，封装handler的ServeHTTP方法根本就不会被调用。因此封装的handler根本不会有任何输出，实际上它根本就不知道有这样一个请求到来。</p><p>现在我们已经完成了自己的中间件，来把它放到应用中。这次我们不把Handler直接放到net/http服务中，而是先把Handler封装到中间件中。</p><pre><code>singleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)

http.ListenAndServe(&quot;:8080&quot;, singleHosted)
</code></pre><h3 id="另外一种方法">另外一种方法</h3><p>我们刚才写的中间件实在是太简单了，只有仅仅15行代码。为了写这样的中间件，引入了一个不太通用的方法。由于Go支持函数第一型和闭包，并且拥有简洁的http.HandlerFunc包装器，我们可以将其实现为一个简单的函数，而不是写一个单独的类型。下面是基于函数的中间件版本。</p><pre><code>func SingleHost(handler http.Handler, allowedHost string) http.Handler {

    ourFunc := func(w http.ResponseWriter, r *http.Request) {

        host := r.Host

        if host == allowedHost {

            handler.ServeHTTP(w, r)

        } else {

            w.WriteHeader(403)

        }

    }

    return http.HandlerFunc(ourFunc)

}
</code></pre><p>这里我们声明了一个叫做SingleHost的简单函数，接受一个Handler和允许的主机名。在函数内部，我们创建了一个类似之前版本ServeHTTP的函数。这个内部函数其实是一个闭包，所以它可以从SingleHost外部访问。最终，我们通过<a href="http://golang.org/pkg/net/http/#HandlerFunc">HandlerFunc</a>把这个函数用作http.Handler。</p><p>使用Handler还是定义一个http.Handler类型完全取决于你。对简单的情况而已，一个函数就足够了。但是随着中间件功能的复杂，你应该考虑定义自己的数据结构，把逻辑独立到多个方法中。</p><p>实际上，标准库这两种方法都用了。<a href="http://golang.org/pkg/net/http/#StripPrefix">StripPrefix</a> 是一个返回HandlerFunc的函数。虽然<a href="http://golang.org/pkg/net/http/#TimeoutHandler">TimeoutHandler</a>也是一个函数，但它返回了处理请求的自定义的类型。</p><h3 id="更复杂的情况">更复杂的情况</h3><p>我们的SingleHost中间件非常简单：先检查请求的一个属性，然后要么什么也不管，把请求直接传给封装的Handler；要么自己返回一个响应，根本不让封装的Handler处理这次请求。然而，有些情况是这样的，不但基于请求触发一些动作，还要在封装的Handler处理后做一些扫尾工作，比如修改响应内容等。</p><h3 id="添加数据比较容易">添加数据比较容易</h3><p>如果我们想在封装的handler输出的内容后添加一些数据，我们只需要在handler结束后继续调用Write()即可：</p><pre><code>type AppendMiddleware struct {
    handler http.Handler
}

func (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    a.handler.ServeHTTP(w, r)
    w.Write([]byte(&quot;Middleware says hello.&quot;))
}
</code></pre><p>响应内容现在就应该包含封装的handler的内容，再加上Middleware says hello.</p><h3 id="问题是">问题是</h3><p>做其他的响应内容操作比较麻烦。比如，如果我们想在响应内容前写入一些数据。如果我们在封装的handler前调用Write()，那么封装的handler就好失去对HTTP状态码和HTTP头的控制。因为第一次调用Write()会直接将头输出。</p><p>想要修改原有输出（比如，替换其中的某些字符串），改变特定的HTTP头，设置不同的状态码也都因为同样的原因而不可行：当封装的handler返回时，上述数据早已被发送给客户端了。</p><p>为了处理这样的需求，我们需要一种特殊的可以用做buffer的ResponseWriter,它能够收集、暂存输出以用于修改等操作，最后再发送给客户端。我们可以将这个带buffer的ResponseWriter传给封装的handler，而不是真实的RW，这样就避免直接发送数据给客户端。</p><p>幸运的是，在Go标准库中确实存在这样一个工具。net/http/httptest中的<a href="http://golang.org/pkg/net/http/httptest/#ResponseRecorder">ResponseRecorder</a>就是这样的：它保存状态码，一个保存响应头的字典，将输出累计在buffer中。尽管是用于测试（这个包名暗示了这一点），它还是很好的满足了我们的需求。</p><p>让我们看一个使用ResponseRecorder的例子，这里修改了响应内容的所有东西，是为了更完整的演示。</p><pre><code>type ModifierMiddleware struct {

    handler http.Handler

}

func (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {

    rec := httptest.NewRecorder()

    // passing a ResponseRecorder instead of the original RW

    m.handler.ServeHTTP(rec, r)

    // after this finishes, we have the response recorded

    // and can modify it before copying it to the original RW

    // we copy the original headers first

    for k, v := range rec.Header() {

        w.Header()[k] = v

    }

    // and set an additional one

    w.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)

    // only then the status code, as this call writes out the headers 

    w.WriteHeader(418)

    // the body hasn't been written (to the real RW) yet,

    // so we can prepend some data.

    w.Write([]byte(&quot;Middleware says hello again. &quot;))

    // then write out the original body

    w.Write(rec.Body.Bytes())

}
</code></pre><p>下面是我们包装的handler的输出。如果不用我们的中间件封装，原来的handler仅仅会输出Success！。</p><pre><code>HTTP/1.1 418 I'm a teapot

X-We-Modified-This: Yup

Content-Type: text/plain; charset=utf-8

Content-Length: 37

Date: Tue, 03 Sep 2013 18:41:39 GMT

Middleware says hello again. Success!
</code></pre><p>这种方式提供了非常大的便利。被封装的handler现在完全在我们的控制之下：即使在其返回之后，我们也可以以任意方式操作输出。</p><h3 id="和其他handlers共享数据">和其他handlers共享数据</h3><p>在不同的情况下，中间件可以需要给其他的中间件或者应用程序暴露特定的信息。比如，nosurf需要给用户提供一种获取CSRF 密钥的方式以及错误原因（如果有错误的话）。</p><p>对这种需求，一个合适的模型就是使用一个隐藏的map，将http.Request指针指向需要的数据，然后暴露一个包级别（handler级别）的函数来访问这些数据。</p><p>我在nosurf中也使用了这种模型。这里，我创建了一个全局的上下文map。注意到，由于默认情况下Go的map并不是[并发访问安全](<a href="http://blog.golang.org/go-maps-in-action#TOC_6">http://blog.golang.org/go-maps-in-action#TOC_6</a>.）的，需要一个mutex。</p><pre><code>type csrfContext struct {

    token string

    reason error

}

var (

    contextMap = make(map[*http.Request]*csrfContext)

    cmMutex    = new(sync.RWMutex)

)
</code></pre><p>使用handler设置数据，然后通过暴露的函数Token()来获取数据。</p><pre><code>func Token(req *http.Request) string {

    cmMutex.RLock()

    defer cmMutex.RUnlock()

    ctx, ok := contextMap[req]

    if !ok {

            return &quot;&quot;

    }

    return ctx.token

}
</code></pre><p>你可以在nosurf的代码库<a href="https://github.com/justinas/nosurf/blob/master/context.go">context.go</a>中找到完整的实现。</p><p>虽然我选择在nosurf中自己实现这种需求，但实际上存在一个方便的 <a href="http://www.gorillatoolkit.org/pkg/context#ClearHandler">gorilla/context</a>包，它实现了一个通用的保存请求信息的map。在大多数情况下，这个包足以满足你的需求，避免你在自己实现一个共享存储时踩坑。它甚至还有一个<a href="http://www.gorillatoolkit.org/pkg/context#ClearHandler">自己的中间件</a>能在请求处理结束之后清除请求信息。</p><h3 id="总结">总结</h3><p>这篇文章的目的是吸引Go用户对中间件概念的注意以及展示使用Go写中间件的一些基本组件。尽管Go是一个相对年轻的开发语言，Go拥有非常<a href="http://justinas.org/embrace-gos-http-tools/">漂亮的标准HTTP接口</a>。这也是用Go写中间件是个非常简单甚至快乐的过程的原因之一。</p><p>然而，目前Go仍然缺乏高质量的HTTP工具。我之前提到的<a href="http://justinas.org/writing-http-middleware-in-go/#usecases">Go中间件想法</a>，大多都还没实现。现在你已经知道如何用Go写中间件了，为什么不自己做一个呢？</p><p>PS，你可以在一个<a href="https://gist.github.com/justinas/7059324">GitHub gist</a>中找到这篇文章中所有的中间件例子。</p><hr><p>原文链接： <a href="http://justinas.org/writing-http-middleware-in-go/">Writing HTTP Middleware in Go</a><br>转载自： <a href="http://blog.jobbole.com/">伯乐在线</a> - <a href="http://blog.jobbole.com/author/codefor/">Codefor</a></p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/http.html">http</a> <a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/shen-ru--go-playground-nei-mu.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">深入GoPlayground内幕</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/golangbiao-zhun-ku-de-fen-xi-osbao-6.html"><span class="next-text nav-default">golang标准库的分析os包(6)</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2018 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="www.miitbeian.gov.cn">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script><script src="https://xiongzhang.baidu.com/sdk/c.js?appid=1614189312904082"></script><script>cambrian.render('tail')</script></body></html>