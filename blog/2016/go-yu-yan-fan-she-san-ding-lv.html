<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Go语言反射三定律 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="简介 Reflection（反射）在计算机中表示 程序能够检查自身结构的能力，尤其是类型。它是元编程的一种形式，也是最容易让人迷惑的一部分。 本文"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/go-yu-yan-fan-she-san-ding-lv.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="Go语言反射三定律"><meta property="og:description" content="简介 Reflection（反射）在计算机中表示 程序能够检查自身结构的能力，尤其是类型。它是元编程的一种形式，也是最容易让人迷惑的一部分。 本文"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/go-yu-yan-fan-she-san-ding-lv.html"><meta property="article:published_time" content="2016-12-31T11:33:15&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:33:15&#43;08:00"><meta itemprop="name" content="Go语言反射三定律"><meta itemprop="description" content="简介 Reflection（反射）在计算机中表示 程序能够检查自身结构的能力，尤其是类型。它是元编程的一种形式，也是最容易让人迷惑的一部分。 本文"><meta itemprop="datePublished" content="2016-12-31T11:33:15&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:33:15&#43;08:00"><meta itemprop="wordCount" content="5425"><meta itemprop="keywords" content="反射,reflect,golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go语言反射三定律"><meta name="twitter:description" content="简介 Reflection（反射）在计算机中表示 程序能够检查自身结构的能力，尤其是类型。它是元编程的一种形式，也是最容易让人迷惑的一部分。 本文"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Go语言反射三定律</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 5425 字 </span><span class="more-meta">预计阅读 11 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#简介">简介</a></li><li><a href="#阅读建议">阅读建议</a></li><li><a href="#类型和接口">类型和接口</a></li><li><a href="#接口变量的表示">接口变量的表示</a></li><li><a href="#反射第一定律-反射可以将-接口类型变量-转换为-反射类型对象">反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”。</a></li><li><a href="#反射第二定律-反射可以将-反射类型对象-转换为-接口类型变量">反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”。</a></li><li><a href="#反射第三定律-如果要修改-反射类型对象-其值必须是-可写的-settable">反射第三定律：如果要修改“反射类型对象”，其值必须是“可写的”（settable）。</a></li><li><a href="#结构体-struct">结构体（struct）</a></li><li><a href="#结论">结论</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="简介">简介</h2><p>Reflection（反射）在计算机中表示 程序能够检查自身结构的能力，尤其是类型。它是元编程的一种形式，也是最容易让人迷惑的一部分。</p><p>本文中，我们将解释Go语言中反射的运作机制。每个编程语言的反射模型不大相同，很多语言索性就不支持反射（C、C++）。由于本文是介绍Go语言的，所以当我们谈到“反射”时，默认为是Go语言中的反射。</p><h2 id="阅读建议">阅读建议</h2><p>本文中，我们将解释Go语言中反射的运作机制。每个编程语言的反射模型不大相同，很多语言索性就不支持反射（C、C++）。</p><p>由于本文是介绍Go语言的，所以当我们谈到“反射”时，默认为是Go语言中的反射。</p><p>虽然Go语言没有继承的概念，但为了便于理解，如果一个struct A 实现了 interface B的所有方法时，我们称之为“继承”。</p><h2 id="类型和接口">类型和接口</h2><p>反射建立在类型系统之上，因此我们从类型基础知识说起。</p><p>Go是静态类型语言。每个变量都有且只有一个静态类型，在编译时就已经确定。比如 int、float32、*MyType、[]byte。 如果我们做出如下声明：</p><pre><code>type MyInt int

var i int
var j MyInt
</code></pre><p>上面的代码中，变量 i 的类型是 int，j 的类型是 MyInt。 所以，尽管变量 i 和 j 具有共同的底层类型 int，但它们的静态类型并不一样。不经过类型转换直接相互赋值时，编译器会报错。</p><p>关于类型，一个重要的分类是 接口类型（interface），每个接口类型都代表固定的方法集合。一个接口变量就可以存储（或“指向”，接口变量类似于指针）任何类型的具体值，只要这个值实现了该接口类型的所有方法。一组广为人知的例子是 io.Reader 和 io.Writer， Reader 和 Writer 类型来源于 io包，声明如下：</p><pre><code>// Reader is the interface that wraps the basic Read method.
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer is the interface that wraps the basic Write method.
type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre><p>任何实现了 Read（Write）方法的类型，我们都称之为继承了 io.Reader（io.Writer）接口。换句话说， 一个类型为 io.Reader 的变量 可以指向（接口变量类似于指针）任何类型的变量，只要这个类型实现了Read 方法：</p><pre><code>var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// and so on
</code></pre><p>要时刻牢记：不管变量 r 指向的具体值是什么，它的类型永远是 io.Reader。再重复一次：Go语言是静态类型语言，变量 r 的静态类型是 io.Reader。</p><p>一个非常非常重要的接口类型是空接口，即：</p><pre><code>interface{}
</code></pre><p>它代表一个空集，没有任何方法。由于任何具体的值都有 零或更多个方法，因此类型为interface{} 的变量能够存储任何值。</p><p>有人说，Go的接口是动态类型的。这个说法是错的！接口变量也是静态类型的，它永远只有一个相同的静态类型。如果在运行时它存储的值发生了变化，这个值也必须满足接口类型的方法集合。</p><p>由于反射和接口两者的关系很密切，我们必须澄清这一点。</p><h2 id="接口变量的表示">接口变量的表示</h2><p>Russ Cox 在2009年写了一篇文章介绍 Go中接口变量的表示形式，具体参考文章末尾的链接“Go语言接口的表示”。这里我们不需要重复所有的细节，只做一个简单的总结。</p><p>Interface变量存储一对值：赋给该变量的具体的值、值类型的描述符。更准确一点来说，值就是实现该接口的底层数据，类型是底层数据类型的描述。举个例子：</p><pre><code>var r io.Reader
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty
</code></pre><p>在这个例子中，变量 r 在结构上包含一个 (value, type) 对：(tty, <em>os.File)。注意：类型</em> os.File 不仅仅实现了 Read 方法。虽然接口变量只提供 Read 函数的调用权，但是底层的值包含了关于这个值的所有类型信息。所以我们能够做这样的类型转换：</p><pre><code>var w io.Writer
w = r.(io.Writer)
</code></pre><p>上面代码的第二行是一个类型断言，它断定变量 r 内部的实际值也继承了 io.Writer接口，所以才能被赋值给 w。赋值之后，w 就指向了 (tty, *os.File) 对，和变量 r 指向的是同一个 (value, type) 对。不管底层具体值的方法集有多大，由于接口的静态类型限制，接口变量只能调用特定的一些方法。</p><p>我们继续往下看：</p><pre><code>var empty interface{}
empty = w
</code></pre><p>这里的空接口变量 empty 也包含 (tty, *os.File) 对。这一点很容易理解：空接口变量可以存储任何具体值以及该值的所有描述信息。</p><p>细心的朋友可能会发现，这里没有使用类型断言，因为变量 w 满足 空接口的所有方法（传说中的“无招胜有招”）。在前一个例子中，我们把一个具体值 从 io.Reader 转换为 io.Writer 时，需要显式的类型断言，是因为 io.Writer 的方法集合 不是 io.Reader 的子集。</p><p>另外需要注意的一点是，(value, type) 对中的 type 必须是 具体的类型（struct或基本类型），不能是 接口类型。 接口类型不能存储接口变量。</p><p>关于接口，我们就介绍到这里，下面我们看看Go语言的反射三定律。</p><h2 id="反射第一定律-反射可以将-接口类型变量-转换为-反射类型对象">反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”。</h2><p>注：这里反射类型指 <code>reflect.Type</code> 和 <code>reflect.Value</code>。</p><p>从用法上来讲，反射提供了一种机制，允许程序在运行时检查接口变量内部存储的 (value, type) 对。在最开始，我们先了解下 reflect 包的两种类型：Type 和 Value。这两种类型使访问接口内的数据成为可能。它们对应两个简单的方法，分别是 reflect.TypeOf 和 reflect.ValueOf，分别用来读取接口变量的 reflect.Type 和 reflect.Value 部分。当然，从 reflect.Value 也很容易获取到 reflect.Type。目前我们先将它们分开。</p><p>首先，我们下看 reflect.TypeOf：</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    var x float64 = 3.4
    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))
}
</code></pre><p>这段代码会打印出：</p><pre><code>type: float64
</code></pre><p>你可能会疑惑：为什么没看到接口？这段代码看起来只是把一个 float64类型的变量 x 传递给 reflect.TypeOf，并没有传递接口。事实上，接口就在那里。查阅一下TypeOf 的文档，你会发现 reflect.TypeOf 的函数签名里包含一个空接口：</p><pre><code>// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
</code></pre><p>我们调用 reflect.TypeOf(x) 时，x 被存储在一个空接口变量中被传递过去； 然后reflect.TypeOf 对空接口变量进行拆解，恢复其类型信息。</p><p>函数 reflect.ValueOf 也会对底层的值进行恢复（这里我们忽略细节，只关注可执行的代码）：</p><pre><code>var x float64 = 3.4
fmt.Println(&quot;value:&quot;, reflect.ValueOf(x))
</code></pre><p>上面这段代码打印出：</p><pre><code>value: &lt;float64 Value&gt;
</code></pre><p>类型 reflect.Type 和 reflect.Value 都有很多方法，我们可以检查和使用它们。这里我们举几个例子。类型 reflect.Value 有一个方法 Type()，它会返回一个 reflect.Type 类型的对象。Type和 Value都有一个名为 Kind 的方法，它会返回一个常量，表示底层数据的类型，常见值有：Uint、Float64、Slice等。Value类型也有一些类似于Int、Float的方法，用来提取底层的数据。Int方法用来提取 int64, Float方法用来提取 float64，参考下面的代码：</p><pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;type:&quot;, v.Type())
fmt.Println(&quot;kind is float64:&quot;, v.Kind() == reflect.Float64)
fmt.Println(&quot;value:&quot;, v.Float())
</code></pre><p>上面这段代码会打印出：</p><pre><code>type: float64
kind is float64: true
value: 3.4
</code></pre><p>还有一些用来修改数据的方法，比如SetInt、SetFloat，在讨论它们之前，我们要先理解“可修改性”（settability），这一特性会在“反射第三定律”中进行详细说明。</p><p>反射库提供了很多值得列出来单独讨论的属性。首先是介绍下Value 的 getter 和 setter 方法。为了保证API 的精简，这两个方法操作的是某一组类型范围最大的那个。比如，处理任何含符号整型数，都使用 int64。也就是说 Value 类型的Int 方法返回值为 int64类型，SetInt 方法接收的参数类型也是 int64 类型。实际使用时，可能需要转化为实际的类型：</p><pre><code>var x uint8 = 'x'
v := reflect.ValueOf(x)
fmt.Println(&quot;type:&quot;, v.Type())                            // uint8.
fmt.Println(&quot;kind is uint8: &quot;, v.Kind() == reflect.Uint8) // true.
x = uint8(v.Uint())                // v.Uint returns a uint64.
</code></pre><p>第二个属性是反射类型变量（reflection object）的 Kind 方法 会返回底层数据的类型，而不是静态类型。如果一个反射类型对象包含一个用户定义的整型数，看代码：</p><pre><code>type MyInt int
var x MyInt = 7
v := reflect.ValueOf(x)
</code></pre><p>上面的代码中，虽然变量 v 的静态类型是MyInt，不是 int，Kind 方法仍然返回 reflect.Int。换句话说， Kind 方法不会像 Type 方法一样区分 MyInt 和 int。</p><h2 id="反射第二定律-反射可以将-反射类型对象-转换为-接口类型变量">反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”。</h2><p>和物理学中的反射类似，Go语言中的反射也能创造自己反面类型的对象。</p><p>根据一个 reflect.Value 类型的变量，我们可以使用 Interface 方法恢复其接口类型的值。事实上，这个方法会把 type 和 value 信息打包并填充到一个接口变量中，然后返回。其函数声明如下：</p><pre><code>// Interface returns v's value as an interface{}.
func (v Value) Interface() interface{}
</code></pre><p>然后，我们可以通过断言，恢复底层的具体值：</p><pre><code>y := v.Interface().(float64) // y will have type float64.
fmt.Println(y)
</code></pre><p>上面这段代码会打印出一个 float64 类型的值，也就是 反射类型变量 v 所代表的值。</p><p>事实上，我们可以更好地利用这一特性。标准库中的 fmt.Println 和 fmt.Printf 等函数都接收空接口变量作为参数，fmt 包内部会对接口变量进行拆包（前面的例子中，我们也做过类似的操作）。因此，fmt 包的打印函数在打印 reflect.Value 类型变量的数据时，只需要把 Interface 方法的结果传给 格式化打印程序：</p><pre><code>fmt.Println(v.Interface())
</code></pre><p>你可能会问：问什么不直接打印 v ，比如 fmt.Println(v)？ 答案是 v 的类型是 reflect.Value，我们需要的是它存储的具体值。由于底层的值是一个 float64，我们可以格式化打印：</p><pre><code>fmt.Printf(&quot;value is %7.1e\n&quot;, v.Interface())
</code></pre><p>上面代码的打印结果是：</p><pre><code>3.4e+00
</code></pre><p>同样，这次也不需要对 v.Interface() 的结果进行类型断言。空接口值内部包含了具体值的类型信息，Printf 函数会恢复类型信息。</p><p>简单来说，Interface 方法和 ValueOf 函数作用恰好相反，唯一一点是，返回值的静态类型是 interface{}。</p><p>我们重新表述一下：Go的反射机制可以将“接口类型的变量”转换为“反射类型的对象”，然后再将“反射类型对象”转换过去。</p><h2 id="反射第三定律-如果要修改-反射类型对象-其值必须是-可写的-settable">反射第三定律：如果要修改“反射类型对象”，其值必须是“可写的”（settable）。</h2><p>这条定律很微妙，也很容易让人迷惑。但是如果你从第一条定律开始看，应该比较容易理解。</p><p>下面这段代码不能正常工作，但是非常值得研究：</p><pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
</code></pre><p>如果你运行这段代码，它会抛出抛出一个奇怪的异常：</p><pre><code>panic: reflect.Value.SetFloat using unaddressable value
</code></pre><p>这里问题不在于值 7.1 不能被寻址，而是因为变量 v 是“不可写的”。“可写性”是反射类型变量的一个属性，但不是所有的反射类型变量都拥有这个属性。</p><p>我们可以通过 CanSet 方法检查一个 reflect.Value 类型变量的“可写性”。对于上面的例子，可以这样写：</p><pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;settability of v:&quot;, v.CanSet())
</code></pre><p>上面这段代码打印结果是：</p><pre><code>settability of v: false
</code></pre><p>对于一个不具有“可写性”的 Value类型变量，调用 Set 方法会报出错误。首先，我们要弄清楚什么“可写性”。</p><p>“可写性”有些类似于寻址能力，但是更严格。它是反射类型变量的一种属性，赋予该变量修改底层存储数据的能力。“可写性”最终是由一个事实决定的：反射对象是否存储了原始值。举个代码例子：</p><pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
</code></pre><p>这里我们传递给 reflect.ValueOf 函数的是变量 x 的一个拷贝，而非 x 本身。想象一下，如果下面这行代码能够成功执行：</p><pre><code>v.SetFloat(7.1)
</code></pre><p>答案是：如果这行代码能够成功执行，它不会更新 x ，虽然看起来变量 v 是根据 x 创建的。相反，它会更新 x 存在于 反射对象 v 内部的一个拷贝，而变量 x 本身完全不受影响。这会造成迷惑，并且没有任何意义，所以是不合法的。“可写性”就是为了避免这个问题而设计的。</p><p>这看起来很诡异，事实上并非如此，而且类似的情况很常见。考虑下面这行代码：</p><pre><code>f(x)
</code></pre><p>上面的代码中，我们把变量 x 的一个拷贝传递给函数，因此不期望它会改变 x 的值。如果期望函数 f 能够修改变量 x，我们必须传递 x 的地址（即指向 x 的指针）给函数 f，如下：</p><pre><code>f(&amp;x)
</code></pre><p>你应该很熟悉这行代码，反射的工作机制是一样的。如果你想通过反射修改变量 x，就咬吧想要修改的变量的指针传递给 反射库。</p><p>首先，像通常一样初始化变量 x，然后创建一个指向它的 反射对象，名字为 p：</p><pre><code>var x float64 = 3.4
p := reflect.ValueOf(&amp;x) // Note: take the address of x.
fmt.Println(&quot;type of p:&quot;, p.Type())
fmt.Println(&quot;settability of p:&quot;, p.CanSet())
</code></pre><p>这段代码的输出是：</p><pre><code>type of p: *float64
settability of p: false
</code></pre><p>反射对象 p 是不可写的，但是我们也不像修改 p，事实上我们要修改的是 *p。为了得到 p 指向的数据，可以调用 Value 类型的 Elem 方法。Elem 方法能够对指针进行“解引用”，然后将结果存储到反射 Value类型对象 v中：</p><pre><code>v := p.Elem()
fmt.Println(&quot;settability of v:&quot;, v.CanSet())
</code></pre><p>在上面这段代码中，变量 v 是一个可写的反射对象，代码输出也验证了这一点：</p><pre><code>settability of v: true
</code></pre><p>由于变量 v 代表 x， 因此我们可以使用 v.SetFloat 修改 x 的值：</p><pre><code>v.SetFloat(7.1)
fmt.Println(v.Interface())
fmt.Println(x)
</code></pre><p>上面代码的输出如下：</p><pre><code>7.1
7.1
</code></pre><p>反射不太容易理解，reflect.Type 和 reflect.Value 会混淆正在执行的程序，但是它做的事情正是编程语言做的事情。你只需要记住：只要反射对象要修改它们表示的对象，就必须获取它们表示的对象的地址。</p><h2 id="结构体-struct">结构体（struct）</h2><p>在前面的例子中，变量 v 本身并不是指针，它只是从指针衍生而来。把反射应用到结构体时，常用的方式是 使用反射修改一个结构体的某些字段。只要拥有结构体的地址，我们就可以修改它的字段。</p><p>下面通过一个简单的例子对结构体类型变量 t 进行分析。</p><p>首先，我们创建了反射类型对象，它包含一个结构体的指针，因为后续会修改。</p><p>然后，我们设置 typeOfT 为它的类型，并遍历所有的字段。</p><p>注意：我们从 struct 类型提取出每个字段的名字，但是每个字段本身也是常规的 reflect.Value 对象。</p><pre><code>type T struct {
    A int
    B string
}
t := T{23, &quot;skidoo&quot;}
s := reflect.ValueOf(&amp;t).Elem()
typeOfT := s.Type()
for i := 0; i &lt; s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf(&quot;%d: %s %s = %v\n&quot;, i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}
</code></pre><p>上面这段代码的输出如下：</p><pre><code>0: A int = 23
1: B string = skidoo
</code></pre><p>这里还有一点需要指出：变量 T 的字段都是首字母大写的（暴露到外部），因为struct中只有暴露到外部的字段才是“可写的”。</p><p>由于变量 s 包含一个“可写的”反射对象，我们可以修改结构体的字段：</p><pre><code>f.Interface())s.Field(0).SetInt(77)
s.Field(1).SetString(&quot;Sunset Strip&quot;)
fmt.Println(&quot;t is now&quot;, t)
</code></pre><p>上面代码的输出如下：</p><pre><code>t is now {77 Sunset Strip}
</code></pre><p>如果变量 s 是通过 t ，而不是 &amp;t 创建的，调用 SetInt 和 SetString 将会失败，因为 t 的字段不是“可写的”。</p><h2 id="结论">结论</h2><p>最后再次重复一遍反射三定律：</p><ol><li><p>反射可以将“接口类型变量”转换为“反射类型对象”。</p></li><li><p>反射可以将“反射类型对象”转换为“接口类型变量”。</p></li><li><p>如果要修改“反射类型对象”，其值必须是“可写的”（settable）。<br>一旦你理解了这些定律，使用反射将会是一件非常简单的事情。它是一件强大的工具，使用时务必谨慎使用，更不要滥用。</p></li></ol><p>关于反射，我们还有很多内容没有讨论，包括基于管道的发送和接收、内存分配、使用slice和map、调用方法和函数，由于本文已经非常长了，这些话题在后续的文章中介绍。</p><hr><p>原作者 Rob Pike，翻译Oscar</p><p>相关链接：</p><ul><li><p>原文链接：<a href="https://blog.golang.org/laws-of-reflection">https://blog.golang.org/laws-&hellip;</a></p></li><li><p>reflect 包：<a href="https://golang.org/pkg/reflect/">https://golang.org/pkg/reflect/</a></p></li></ul><p>扫码关注微信公众号“深入Go语言”</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%8F%8D%E5%B0%84.html">反射</a> <a href="/tags/reflect.html">reflect</a> <a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/golangshi-xian-ecbmo-shi-3dessuan-fa.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">Golang实现ECB模式3DES算法</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/yi-bu-yi-bu-jiao-ni-xie-btchong-zi-xiu-tan-qi-zhi-yi----yuan-li-pian.html"><span class="next-text nav-default">一步一步教你写BT种子嗅探器之一---原理篇</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>