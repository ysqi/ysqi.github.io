<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>golang笔记 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="emacs 开发环境 spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要gocode来辅助。 安装所需的命令 go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v golang.org/x/tools/cmd/guru"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2016/golang-bi-ji.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="golang笔记"><meta property="og:description" content="emacs 开发环境 spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要gocode来辅助。 安装所需的命令 go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v golang.org/x/tools/cmd/guru"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2016/golang-bi-ji.html"><meta property="article:published_time" content="2016-12-31T11:32:28&#43;08:00"><meta property="article:modified_time" content="2016-12-31T11:32:28&#43;08:00"><meta itemprop="name" content="golang笔记"><meta itemprop="description" content="emacs 开发环境 spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要gocode来辅助。 安装所需的命令 go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v golang.org/x/tools/cmd/guru"><meta itemprop="datePublished" content="2016-12-31T11:32:28&#43;08:00"><meta itemprop="dateModified" content="2016-12-31T11:32:28&#43;08:00"><meta itemprop="wordCount" content="2263"><meta itemprop="keywords" content="golang,emacs,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="golang笔记"><meta name="twitter:description" content="emacs 开发环境 spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要gocode来辅助。 安装所需的命令 go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v golang.org/x/tools/cmd/guru"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">golang笔记</h1><div class="post-meta"><span class="post-time">2016-12-31</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 2263 字 </span><span class="more-meta">预计阅读 5 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><ul><li><a href="#emacs-开发环境">emacs 开发环境</a></li></ul></li><li><a href="#go">GO</a><ul><li><a href="#语法">语法</a></li><li><a href="#基本类型">基本类型</a></li><li><a href="#符号">符号</a></li><li><a href="#抽象">抽象</a></li><li><a href="#并行">并行</a></li><li><a href="#调用c库">调用C库</a></li></ul></li></ul></nav></div></div><div class="post-content"><h2 id="emacs-开发环境">emacs 开发环境</h2><p>spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要<a href="https://github.com/nsf/gocode">gocode</a>来辅助。</p><ol><li><p>安装所需的命令</p><p>go get -u -v github.com/nsf/gocode<br>go get -u -v github.com/rogpeppe/godef go get -u -v<br>golang.org/x/tools/cmd/guru go get -u -v<br>golang.org/x/tools/cmd/gorename go get -u -v<br>golang.org/x/tools/cmd/goimports</p></li><li><p>配置文件</p><p>将gocode中的<code>go-autocomplete.el</code>拷贝至<code>elpa/go-mode</code>下<br>向space macs手动添加包：<code>dotspacemacs-additional-packages '(go-autocomplete)</code><br>在<code>dotspacemace/user-config</code>中添加以下内容</p><pre><code>(require 'go-autocomplete)
(require 'auto-complete-config)
(ac-config-default)
</code></pre></li></ol><hr><h1 id="go">GO</h1><p><a href="http://docs.studygolang.com/pkg/">package 手册</a> 、<a href="https://github.com/gopl-zh/gopl-zh.github.com">go语言圣经</a></p><h2 id="语法">语法</h2><ol><li><p>声明 ：<code>var|const|type|func name (类型) (值)</code></p><p><code>var</code> 显式声明一个变元。<code>var name Type</code><br><code>:=</code> 语法可以隐式地声明一个变元。<code>name := f() | a</code><br>隐式声明的变元的作用域是可以被覆盖的，但显式的不能。</p><pre><code>var a int //1.会导致3出错
a := 1    //2.不会导致3处出错
{
a:= 2     //3.
}
</code></pre><p><code>const a=2</code>, <code>const a float64=2</code></p><p><code>type name define</code>，<code>define= Type | struct{..}|interface{}</code></p><p><code>func (name Type)* name (arg...) {...}</code><br>打*号的部分是 接收器(receiver)，用于扩展指定<code>Type</code>（必须是自定义类型）。</p><pre><code>type Point struct{ X, Y float64 }
// traditional function
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
type Float64 float64 //
func (p Float64) Distance(q Float64) float64 {
    return math.Abs(float64(p - q))
}
var x, y Float64 = 1.0, 2
x.Distance(y)
</code></pre><p>匿名函数：<code>func(r rune) rune { return r + 1 }</code><br>便捷操作</p><pre><code>import (
    &quot;C&quot;
    &quot;fmt&quot;
    &quot;math&quot;
)
const | var (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)
var a,b,c Type
</code></pre></li><li><p>控制结构<br><strong>if</strong>语句</p><pre><code>if a, b := 21, 3; a &gt; b {
    fmt.Println(&quot;a&gt;b ? true&quot;)
}else {
}

for i, j := 1, 10; i &lt; j; i,j=i+1,j+1 {  //死循环
    fmt.Println(i)
}
</code></pre><p><strong>switch</strong>语句</p><pre><code>switch ch {
case '0': 
    fallthrough   //必须是最后一个语句
case '1':
    cl = &quot;Int&quot;
case 'A': 
case 'a':
    fallthrough
    cl = &quot;ABC&quot;    //error
default:
    cl = &quot;Other Char&quot;
}
</code></pre></li><li><p>类型转换<br>语法：</p><pre><code>&lt;目标类型&gt; ( &lt;表达式&gt; )
&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言
&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言

var3 := int64(var1)
var i interface{} = &quot;TT&quot;
j, b := i.(int)
if b {
    fmt.Printf(&quot;%T-&gt;%d\n&quot;, j, j)
} else {
    fmt.Println(&quot;类型不匹配&quot;)
}
</code></pre></li></ol><h2 id="基本类型">基本类型</h2><ol><li><p>数组</p><pre><code>q := [...]int{1, 2, 3}
q := [3]int{1, 2, 3} //等价
fmt.Printf(&quot;%T\n&quot;, q) // &quot;[3]int&quot;

r := [...]int{99: -1}// {下表：值}，填充默认值
</code></pre></li><li><p>Slice<br>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作<code>[]T</code>，其中T代表slice中元素的类型；数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。<br><code>array[i:j]</code>来创建一个Slice，0 ≤ i≤ j≤ cap(s)</p><pre><code>array := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
front := array[0:5]
mid := array[3:8]
tail := array[4:9]
front[4] = 555 //3个数都被修改
array[5] = 605 //会导致 mid,tail 修改
</code></pre><p><strong>注意</strong></p><pre><code>    array := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    front := array[0:5]
    mid := array[3:8]
    tail := array[4:9]
    nf := append(tail, 66) //1.
    nf := append(mid, 66) //2.
    nf[0] = 5555
    fmt.Println(front, mid, tail, nf)
    //1. [1 2 3 4 601] [4 601 6 7 8] [601 6 7 8 9] [5555 6 7 8 9 66]
    //2. [1 2 3 5555 5] [5555 5 6 7 8] [5 6 7 8 66] [5555 5 6 7 8 66]
</code></pre><p>当原数组够用时，append会直接使用原来的空间。不够时另开一片。</p><p><code>[]T</code>是切片类型 <code>[n]T</code>是数组类型</p></li><li><p>Map<br>我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：</p><pre><code>ages := make(map[string]int) // mapping from strings to ints
ages := map[string]int{
    &quot;alice&quot;:   31,
    &quot;charlie&quot;: 34,
}
</code></pre></li><li><p>结构体</p><pre><code>type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
</code></pre></li><li><p>接口<br>一类有相同方法的对象。</p><pre><code>package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}

var w io.Writer
w = os.Stdout //使用接口
</code></pre></li></ol><h2 id="符号">符号</h2><pre><code>关键字：
        break      default       func     interface   select
        case       defer         go       map         struct
        chan       else          goto     package     switch
        const      fallthrough   if       range       type
        continue   for           import   return      var

内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
</code></pre><ol><li><p>defer ：延迟执行</p><pre><code>    defer println(&quot;p1&quot;) //后被打印
    defer println(&quot;p2&quot;) //先被打印
</code></pre><p>假设defer处声明了一个变量，那么在析构的时候执行内容。</p></li><li><p>range ：配合for使用</p><pre><code>for index, value := range mySlice {
    fmt.Println(&quot;index: &quot; + index)
    fmt.Println(&quot;value: &quot; + value)
}
</code></pre><ul><li><p>for index,char := range string {}</p></li><li><p>for index,value := range array {}</p></li><li><p>for index,value := range slice {}</p></li><li><p>for key,value := range map {}</p></li></ul></li></ol><h2 id="抽象">抽象</h2><p>不同于面向对象的语言先定义一个对象具有哪些抽象行为再实现的思路。<br>GO是先实现一个对象，再检查这个对象是否符合接口规范。</p><ol><li><p>方法<br>扩展某一个类型</p><pre><code>type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
</code></pre></li><li><p>接口<br>一类有相同方法的对象。</p><pre><code>package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}
</code></pre></li></ol><h2 id="并行">并行</h2><ol><li><p>goroutine<br>使用go关键字go</p><pre><code>f()    // call f(); wait for it to return
go f() // create a new goroutine that calls f(); don't wait
</code></pre></li><li><p>channel</p><pre><code>var ch chan int
ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3

ch &lt;- 2 //send
a := ch //receive
</code></pre><p><code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。<br><code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。<br>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</p></li><li><p>select</p><pre><code>select {
case &lt;-ch1:
    // ...
case x := &lt;-ch2:
    // ...use x...
case ch3 &lt;- y:
    // ...
case &lt;-time.After(10 * time.Second):
    //超时机制，不能与default一起
default:
    // ...
}
</code></pre></li></ol><h2 id="调用c库">调用C库</h2><p><a href="https://golang.org/cmd/cgo/">cgo</a></p><pre><code>/*
#cgo CFLAGS: -I/usr/include
#cgo LDFLAGS: -L/usr/lib -lbz2
#include &lt;bzlib.h&gt;
#include &lt;stdlib.h&gt;
bz_stream* bz2alloc() { return calloc(1, sizeof(bz_stream)); }
int bz2compress(bz_stream *s, int action,
                char *in, unsigned *inlen, char *out, unsigned *outlen);
void bz2free(bz_stream* s) { free(s); }
*/
import &quot;C&quot;
</code></pre><p>可以添加一下编译选项：</p><blockquote><p>CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS , LDFLAGS</p></blockquote><p>c代码必须加以注释且后面紧跟<code>import &quot;C&quot;</code></p><p>在Go中使用C的类型</p><blockquote><p>C.char C.schar (signed char) C.uchar (unsigned char) C.short C.ushort (unsigned short) C.int C.uint (unsigned int) C.long C.ulong (unsigned long) C.longlong (long long) C.ulonglong (unsigned long long) C.float C.double C.complexfloat (complex float) C.complexdouble (complex double)</p></blockquote><p>如果是 <code>struct, union, or enum</code> 类型的，会添加前缀 <code>struct_, union_, or enum_</code>。<br>如<code>struct。a{...};</code>在go中变为<code>C.struct_a</code>。<br><code>C.sizeof_T</code> 表示C中某种类型的长度</p><pre><code>package main

// typedef int (*intFunc) ();
//
// int
// bridge_int_func(intFunc f)
// {
//        return f();
// }
//
// int fortytwo()
// {
//        return 42;
// }
import &quot;C&quot;
import &quot;fmt&quot;

func main() {
    f := C.intFunc(C.fortytwo)
    fmt.Println(int(C.bridge_int_func(f)))
    // Output: 42
}
</code></pre><p>在go中不能调用c中<strong>可变参数的函数</strong>。</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2016-12-31</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a> <a href="/tags/emacs.html">emacs</a></div><nav class="post-nav"><a class="prev" href="/blog/2016/nian-du-yu-yan--golang-shi-yong-gan-shou.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">年度语言golang使用感受</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2016/ji-shi-tong-xin-zui-jia-shi-jian.html"><span class="next-text nav-default">及时通信最佳实践</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>