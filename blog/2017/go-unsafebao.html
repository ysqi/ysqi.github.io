<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Gounsafe包 - 虞双齐爱折腾</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="Go unsafe包 unsafe包概述 直到现在（Go1.7），unsafe包含以下资源： 三个函数： // unsafe.Sizeof函数返回操作数在内"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2017/go-unsafebao.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link href="https://cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css" rel="stylesheet" crossorigin="anonymous"><meta property="og:title" content="Gounsafe包"><meta property="og:description" content="Go unsafe包 unsafe包概述 直到现在（Go1.7），unsafe包含以下资源： 三个函数： // unsafe.Sizeof函数返回操作数在内"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2017/go-unsafebao.html"><meta property="article:published_time" content="2017-02-18T11:13:48&#43;08:00"><meta property="article:modified_time" content="2017-02-18T11:13:48&#43;08:00"><meta itemprop="name" content="Gounsafe包"><meta itemprop="description" content="Go unsafe包 unsafe包概述 直到现在（Go1.7），unsafe包含以下资源： 三个函数： // unsafe.Sizeof函数返回操作数在内"><meta itemprop="datePublished" content="2017-02-18T11:13:48&#43;08:00"><meta itemprop="dateModified" content="2017-02-18T11:13:48&#43;08:00"><meta itemprop="wordCount" content="3238"><meta itemprop="keywords" content="Go1.8,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Gounsafe包"><meta name="twitter:description" content="Go unsafe包 unsafe包概述 直到现在（Go1.7），unsafe包含以下资源： 三个函数： // unsafe.Sizeof函数返回操作数在内"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐爱折腾</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐爱折腾</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Gounsafe包</h1><div class="post-meta"><span class="post-time">2017-02-18</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 3238 字 </span><span class="more-meta">预计阅读 7 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><a href="#unsafe包概述">unsafe包概述</a></li><li><a href="#unsafe-sizeof-alignof-和-offsetof">unsafe.Sizeof, Alignof 和 Offsetof</a></li><li><a href="#unsafe-pointer">unsafe.Pointer</a></li><li><a href="#uintptr">uintptr</a></li><li><a href="#合法用例1-在-t和-myt之间转换">合法用例1：在[]T和[]MyT之间转换</a></li><li><a href="#合法用例2-调用sync-atomic包中指针相关的函数">合法用例2: 调用sync/atomic包中指针相关的函数</a></li></ul></nav></div></div><div class="post-content"><p>Go unsafe包</p><h1 id="unsafe包概述">unsafe包概述</h1><p>直到现在（Go1.7），unsafe包含以下资源：</p><p>三个函数：</p><pre><code>// unsafe.Sizeof函数返回操作数在内存中的字节大小,参数可以是任意类型的表达式,但是它并不会对表达式进行求值.
// 一个Sizeof函数调用是一个对应uintptr类型的常量表达式,
// 因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量.
func Sizeof(x ArbitraryType) uintptr

//函数的参数必须是一个字段 x.f, 然后返回 f 字段相对于 x 起始地址的偏移量, 包括可能的空洞.
func Offsetof(x ArbitraryType) uintptr

//unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数.
func Alignof(x ArbitraryType) uintptr
</code></pre><blockquote><p>内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。</p></blockquote><p>和一种类型：</p><pre><code>type Pointer *ArbitraryType
</code></pre><p>这里，ArbitraryType不是一个真正的类型。官方导出这个类型只是出于完善文档的考虑，在其他的库和任何项目中都没有使用价值，除非程序员故意使用它。</p><p> </p><h1 id="unsafe-sizeof-alignof-和-offsetof">unsafe.Sizeof, Alignof 和 Offsetof</h1><blockquote><p>计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。</p><p> </p><p><strong><em>由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐</em></strong>（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。</p></blockquote><p>一个结构体变量 x 以及其在64位机器上的典型的内存. 灰色区域是空洞.</p><pre><code>var x struct {
    a bool
    b int16
    c []int
}
</code></pre><p><img src="https://static.oschina.net/uploads/space/2017/0217/165238_zUMW_1469576.png" alt=""></p><p>对结构体变量的三个字段调用unsafe包相关函数的计算结果如下，</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {

    var x struct {
        a bool
        b int16
        c []int
    }

    //通常情况下布尔和数字类型需要对齐到它们本身的大小(最多8个字节),其它的类型对齐到机器字大小.(64位的机器字大小为64位,8字节)

    fmt.Printf(&quot;%-30s%-30s%-30s%-50s\n&quot;,
        &quot;Row&quot;, &quot;Sizeof&quot;, &quot;Alignof(对齐倍数)&quot;, &quot;Offsetof(偏移量)&quot;)

    fmt.Printf(&quot;%-30s%-30d%-30d%-50s\n&quot;,
        &quot;x&quot;, unsafe.Sizeof(x), unsafe.Alignof(x), &quot;&quot;)
    fmt.Printf(&quot;%-30s%-30d%-30d%-50d\n&quot;,
        &quot;x.a&quot;, unsafe.Sizeof(x.a), unsafe.Alignof(x.a), unsafe.Offsetof(x.a))
    fmt.Printf(&quot;%-30s%-30d%-30d%-50d\n&quot;,
        &quot;x.b&quot;, unsafe.Sizeof(x.b), unsafe.Alignof(x.b), unsafe.Offsetof(x.b))
    fmt.Printf(&quot;%-30s%-30d%-30d%-50d\n&quot;,
        &quot;x.c&quot;, unsafe.Sizeof(x.c), unsafe.Alignof(x.c), unsafe.Offsetof(x.c))
}
</code></pre><p>运行结果，</p><pre><code>Row                           Sizeof                        Alignof(对齐倍数)                 Offsetof(偏移量)                                     
x                             32                            8                                                                               
x.a                           1                             1                             0                                                 
x.b                           2                             2                             2                                                 
x.c                           24                            8                             8                            
</code></pre><p> </p><h1 id="unsafe-pointer">unsafe.Pointer</h1><p>大多数指针类型会写成*T，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的void*类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。</p><p>一个普通的*T类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的*T类型相同。通过将*float64类型指针转化为*uint64类型指针，我们可以查看一个浮点数变量的位模式。</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
    &quot;reflect&quot;
)

func Float64bits(f float64) uint64 {
    fmt.Println(reflect.TypeOf(unsafe.Pointer(&amp;f)))  //unsafe.Pointer
    fmt.Println(reflect.TypeOf((*uint64)(unsafe.Pointer(&amp;f))))  //*uint64
    return *(*uint64)(unsafe.Pointer(&amp;f))
}

func main() {
    fmt.Printf(&quot;%#016x\n&quot;, Float64bits(1.0)) // &quot;0x3ff0000000000000&quot;
}
</code></pre><p>通过转为新类型指针，我们可以更新浮点数的位模式。通过位模式操作浮点数是可以的，<strong><em>但是更重要的意义是指针转换语法让我们可以在不破坏类型系统的前提下向内存写入任意的值。</em></strong></p><p>一个unsafe.Pointer指针也可以被转化为uintptr类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。（第三章内容，uintptr是一个无符号的整型数，足以保存一个地址）这种转换虽然也是可逆的，但是将uintptr转为unsafe.Pointer指针可能会破坏类型系统，因为并不是所有的数字都是有效的内存地址。</p><p>许多将unsafe.Pointer指针转为原生数字，然后再转回为unsafe.Pointer类型指针的操作也是不安全的。比如下面的例子需要将变量x的地址加上b字段地址偏移量转化为*int16类型指针，然后通过该指针更新x.b：</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {

    var x struct {
        a bool
        b int16
        c []int
    }

    // 和 pb := &amp;x.b 等价
    pb := (*int16)(unsafe.Pointer(
        uintptr(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)))
    *pb = 42
    fmt.Println(x.b) // &quot;42&quot;
}
</code></pre><p>上面的写法尽管很繁琐，但在这里并不是一件坏事，因为这些功能应该很谨慎地使用。不要试图引入一个uintptr类型的临时变量，因为它可能会破坏代码的安全性（译注：这是真正可以体会unsafe包为何不安全的例子）。下面段代码是错误的：</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {

    var x struct {
        a bool
        b int16
        c []int
    }

    // NOTE: subtly incorrect!
    tmp := uintptr(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)
    pb := (*int16)(unsafe.Pointer(tmp))
    *pb = 42
    fmt.Println(x.b) // &quot;42&quot;
}
</code></pre><p>产生错误的原因很微妙。有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC。当一个变量被移动，所有的保存改变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动是对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&amp;x.b地址。第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！</p><p>===================</p><p>unsafe.Pointer的使用规则，</p><blockquote><p>（1）任何类型的指针都可以被转化为Pointer</p><p>（2）Pointer可以被转化为任何类型的指针</p><p>（3）uintptr可以被转化为Pointer</p><p>（4）Pointer可以被转化为uintptr</p></blockquote><p>举个例子：</p><pre><code>package main

import (
    &quot;unsafe&quot;
    &quot;fmt&quot;
)

func main() {
    var n int64 = 5
    var pn = &amp;n
    var pf = (*float64)(unsafe.Pointer(pn))
    fmt.Println(*pf) //2.5e-323
    *pf = 3.1415
    fmt.Println(n) //4614256447914709615
}
</code></pre><p>在这个例子中的转换可能是无意义的，但它是安全和合法的。</p><p>uintptr 和 unsafe.Pointer 的互相转换，</p><pre><code>package main

import (
    &quot;unsafe&quot;
    &quot;fmt&quot;
)

func main() {
    a := [4]int{0, 1, 2, 3}
    p := &amp;a[1] // 内存地址
    p1 := unsafe.Pointer(p) 
    p2 := uintptr(p1)
    p3 := unsafe.Pointer(p2)
    fmt.Println(p1) // 0xc420014208
    fmt.Println(p2) // 842350543368
    fmt.Println(p3) // 0xc420014208
}
</code></pre><p> </p><h1 id="uintptr">uintptr</h1><p>关于 uintptr ,</p><pre><code>// uintptr is an integer type that is large enough to hold the bit pattern of
// any pointer.
type uintptr uintptr
</code></pre><p>uintptr 的底层实现如下，在\$GOROOT/src/pkg/runtime/runtime.h中，</p><pre><code>#ifdef _64BIT
typedef uint64          uintptr;
typedef int64           intptr;
typedef int64           intgo; // Go's int
typedef uint64          uintgo; // Go's uint
#else
typedef uint32          uintptr;
typedef int32           intptr;
typedef int32           intgo; // Go's int
typedef uint32          uintgo; // Go's uint
#endif
</code></pre><p>uintptr和intptr是无符号和有符号的指针类型，并且确保在64位平台上是8个字节，在32位平台上是4个字节，uintptr主要用于golang中的指针运算。</p><p> </p><h1 id="合法用例1-在-t和-myt之间转换">合法用例1：在[]T和[]MyT之间转换</h1><p>在这个例子里，我们用int作为T：</p><pre><code>type MyInt int
</code></pre><p>在Golang中，[]int 和 []MyInt是两种不同的类型。 因此，[]int的值不能转换为[]MyInt，反之亦然。 但是在unsafe.Pointer的帮助下，转换是可能的：</p><pre><code>package main

import (
    &quot;unsafe&quot;
    &quot;fmt&quot;
)

func main() {
    type MyInt int

    a := []MyInt{0, 1, 2}
    // b := ([]int)(a) // error: cannot convert a (type []MyInt) to type []int
    b := *(*[]int)(unsafe.Pointer(&amp;a))

    b[0] = 3

    fmt.Println(&quot;a =&quot;, a) // a = [3 1 2]
    fmt.Println(&quot;b =&quot;, b) // b = [3 1 2]

    a[2] = 9

    fmt.Println(&quot;a =&quot;, a) // a = [3 1 9]
    fmt.Println(&quot;b =&quot;, b) // b = [3 1 9]
}
</code></pre><p> </p><h1 id="合法用例2-调用sync-atomic包中指针相关的函数">合法用例2: 调用sync/atomic包中指针相关的函数</h1><p>sync / atomic包中的以下函数的大多数参数和结果类型都是unsafe.Pointer或*unsafe.Pointer：</p><pre><code>// CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.
func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)

// LoadPointer atomically loads *addr.
func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)

// StorePointer atomically stores val into *addr.
func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)

// SwapPointer atomically stores new into *addr and returns the previous *addr value.
func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)
</code></pre><p>要使用这些功能，必须导入unsafe包。</p><pre><code>package main

import (
    &quot;unsafe&quot;
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
    &quot;time&quot;
    &quot;sync&quot;
    &quot;log&quot;
    &quot;math/rand&quot;
)

var data *string

func Data() string {
    p := (*string)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;data))))
    if p == nil {
        return &quot;&quot;
    } else {
        return *p
    }
}

// set data atomically
func SetData(d string) {
    atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&amp;data)), unsafe.Pointer(&amp;d))
}

func main() {

    var wg sync.WaitGroup
    wg.Add(200)

    for range [100]struct{}{} {
        go func() {
            time.Sleep(time.Second * time.Duration(rand.Intn(1000)) / 1000)

            log.Println(Data())
            wg.Done()
        }()
    }

    for i := range [100]struct{}{} {
        go func(i int) {
            time.Sleep(time.Second * time.Duration(rand.Intn(1000)) / 1000)
            s := fmt.Sprint(&quot;#&quot;, i)
            log.Println(&quot;====&quot;, s)

            SetData(s)
            wg.Done()
        }(i)
    }

    wg.Wait()

    fmt.Println(&quot;final data = &quot;, *data)
}
</code></pre><p>转载：</p><p><a href="https://shifei.me/gopl-zh/ch13/ch13-02.html">https://shifei.me/gopl-zh/ch13/ch13-02.html</a></p><p><a href="http://www.open-open.com/lib/view/open1391347613192.html">http://www.open-open.com/lib/view/open1391347613192.html</a></p><p>=======END=======</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2017-02-18</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/go1.8.html">Go1.8</a></div><nav class="post-nav"><a class="prev" href="/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">go协程与主线程强占运行</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2017/go-1_8-http-graceful-ti-yan.html"><span class="next-text nav-default">Go1_8httpgraceful体验</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div id="comments-gitment"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js" crossorigin="anonymous"></script><script type="text/javascript">const gitment = new Gitment({
    id: '转_Gounsafe包.md',
    title: 'Gounsafe包',
    link: decodeURI(location.href),
    desc: 'Go unsafe包 unsafe包概述 直到现在（Go1.7），unsafe包含以下资源： 三个函数： \/\/ unsafe.Sizeof函数返回操作数在内',
    owner: 'ysqi',
    repo: 'ysqi.github.io',
    oauth: {
      client_id: '639ba986c281b9fcf382',
      client_secret: 'b5862135f283dd308a7f226c06980cf50b8e82f1'
    }
  })
  gitment.render('comments-gitment')</script><noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2018 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐</span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js" crossorigin="anonymous"></script><script type="text/javascript" src="https://cdn.bootcss.com/slideout/1.0.1/slideout.min.js" crossorigin="anonymous"></script><script type="text/javascript" src="https://cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/javascript">window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>