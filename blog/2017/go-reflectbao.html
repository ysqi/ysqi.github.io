<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Goreflect包 - 虞双齐的博客</title><link rel="alternate" hreflang="zh" href="https://yushuangqi.com"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="applicable-device" content="pc,mobile"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="mobile-web-app-capable" content="yes"><meta name="author" content="虞双齐"><meta name="description" content="Go reflect包 反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的r"><meta name="keywords" content="智能合约开发, Go语言, 区块链技术"><meta name="generator" content="Hugo 0.37.1"><link rel="canonical" href="https://yushuangqi.com/blog/2017/go-reflectbao.html"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous"><meta property="og:title" content="Goreflect包"><meta property="og:description" content="Go reflect包 反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的r"><meta property="og:type" content="article"><meta property="og:url" content="https://yushuangqi.com/blog/2017/go-reflectbao.html"><meta property="article:published_time" content="2017-02-24T08:31:53&#43;08:00"><meta property="article:modified_time" content="2017-02-24T08:31:53&#43;08:00"><meta itemprop="name" content="Goreflect包"><meta itemprop="description" content="Go reflect包 反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的r"><meta itemprop="datePublished" content="2017-02-24T08:31:53&#43;08:00"><meta itemprop="dateModified" content="2017-02-24T08:31:53&#43;08:00"><meta itemprop="wordCount" content="4082"><meta itemprop="keywords" content="golang,"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Goreflect包"><meta name="twitter:description" content="Go reflect包 反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的r"><!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]--><!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]--></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/" class="logo">虞双齐的博客</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/series.html"><li class="mobile-menu-item">专题</li></a><a href="/categories.html"><li class="mobile-menu-item">分类</li></a><a href="/tags.html"><li class="mobile-menu-item">标签</li></a><a href="/post.html"><li class="mobile-menu-item">归档</li></a><a href="/about.html"><li class="mobile-menu-item">关于</li></a></ul></nav><header id="header" class="header container"><div class="logo-wrapper"><a href="/" class="logo">虞双齐的博客</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/series.html">专题</a></li><li class="menu-item"><a class="menu-item-link" href="/categories.html">分类</a></li><li class="menu-item"><a class="menu-item-link" href="/tags.html">标签</a></li><li class="menu-item"><a class="menu-item-link" href="/post.html">归档</a></li><li class="menu-item"><a class="menu-item-link" href="/about.html">关于</a></li></ul></nav></header><div id="mobile-panel"><main id="main" class="main bg-llight"><div class="content-wrapper"><div id="content" class="content container"><article class="post bg-white"><header class="post-header"><h1 class="post-title">Goreflect包</h1><div class="post-meta"><span class="post-time">2017-02-24</span><div class="post-category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html">编程语言与开发</a></div><span class="more-meta">约 4082 字 </span><span class="more-meta">预计阅读 9 分钟</span></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content always-active"><nav id="TableOfContents"><ul><li><a href="#reflect-type-类型">reflect.Type 类型</a></li><li><a href="#reflect-value-类型">reflect.Value 类型</a></li></ul></nav></div></div><div class="post-content"><p>Go reflect包</p><p>反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Type.</p><p>reflect 包中另一个重要的类型是 Value. 一个 reflect.Value 可以持有一个任意类型的值. 函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Value. 和 reflect.TypeOf 类似, reflect.ValueOf 返回的结果也是对于具体的类型, 但是 reflect.Value 也可以持有一个接口值.</p><h1 id="reflect-type-类型">reflect.Type 类型</h1><p>代码，</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;unsafe&quot;
)

// 嵌套结构体
type ss struct {
    a struct {
        int
        string
    }
    int
    string
    bool
    float64
}

func (s ss) Method1(i int) string  { return &quot;结构体方法1&quot; }
func (s *ss) Method2(i int) string { return &quot;结构体方法2&quot; }

var (
    intValue   = int(0)
    int8Value  = int8(8)
    int16Value = int16(16)
    int32Value = int32(32)
    int64Value = int64(64)

    uIntValue   = uint(0)
    uInt8Value  = uint8(8)
    uInt16Value = uint16(16)
    uInt32Value = uint32(32)
    uInt64Value = uint64(64)

    byteValue    = byte(0)
    runeValue    = rune(0)
    uintptrValue = uintptr(0)

    boolValue   = false
    stringValue = &quot;&quot;

    float32Value = float32(32)
    float64Value = float64(64)

    complex64Value  = complex64(64)
    complex128Value = complex128(128)

    arrayValue  = [5]string{}           // 数组
    sliceValue  = []byte{0, 0, 0, 0, 0} // 切片
    mapValue    = map[string]int{}      // 映射
    chanValue   = make(chan int, 2)     // 通道
    structValue = ss{ // 结构体
            struct {
            int
            string
        }{10, &quot;子结构体&quot;},
        20,
        &quot;结构体&quot;,
        false,
        64.0,
    }

    func1Value = func(a, b, c int) string { // 函数（固定参数）
        return fmt.Sprintf(&quot;固定参数：%v %v %v&quot;, a, b, c)
    }

    func2Value = func(a, b int, c ...int) string { // 函数（动态参数）
        return fmt.Sprintf(&quot;动态参数：%v %v %v&quot;, a, b, c)
    }

    unsafePointer     = unsafe.Pointer(&amp;structValue)            // 通用指针
    reflectType       = reflect.TypeOf(0)                       // 反射类型
    reflectValue      = reflect.ValueOf(0)                      // 反射值
    reflectArrayValue = reflect.ValueOf([]int{1, 2, 3})         // 切片反射值
    interfaceType     = reflect.TypeOf(new(interface{})).Elem() // 反射接口类型
)

// 简单类型
var simpleTypes = []interface{}{
    intValue, &amp;intValue,               // int
    int8Value, &amp;int8Value,             // int8
    int16Value, &amp;int16Value,           // int16
    int32Value, &amp;int32Value,           // int32
    int64Value, &amp;int64Value,           // int64
    uIntValue, &amp;uIntValue,             // uint
    uInt8Value, &amp;uInt8Value,           // uint8
    uInt16Value, &amp;uInt16Value,         // uint16
    uInt32Value, &amp;uInt32Value,         // uint32
    uInt64Value, &amp;uInt64Value,         // uint64
    byteValue, &amp;byteValue,             // byte
    runeValue, &amp;runeValue,             // rune
    uintptrValue, &amp;uintptrValue,       // uintptr
    boolValue, &amp;boolValue,             // bool
    stringValue, &amp;stringValue,         // string
    float32Value, &amp;float32Value,       // float32
    float64Value, &amp;float64Value,       // float64
    complex64Value, &amp;complex64Value,   // complex64
    complex128Value, &amp;complex128Value, // complex128
}

// 复杂类型
var complexTypes = []interface{}{
    arrayValue, &amp;arrayValue,                  // 数组
    sliceValue, &amp;sliceValue,                  // 切片
    mapValue, &amp;mapValue,                      // 映射
    chanValue, &amp;chanValue,                    // 通道
    structValue, &amp;structValue,                // 结构体
    func1Value, &amp;func1Value,                  // 定参函数
    func2Value, &amp;func2Value,                  // 动参函数
    structValue.Method1, structValue.Method2, // 方法
    unsafePointer, &amp;unsafePointer,            // 指针
    reflectType, &amp;reflectType,                // 反射类型
    reflectValue, &amp;reflectValue,              // 反射值
    interfaceType, &amp;interfaceType,            // 接口反射类型
}

// 空值
var unsafeP unsafe.Pointer

// 空接口
var nilInterfece interface{}

func main() {
    // 测试简单类型
    for i := 0; i &lt; len(simpleTypes); i++ {
        PrintInfo(simpleTypes[i])
    }
    // 测试复杂类型
    for i := 0; i &lt; len(complexTypes); i++ {
        PrintInfo(complexTypes[i])
    }
    // 测试单个对象
    PrintInfo(unsafeP)
    PrintInfo(&amp;unsafeP)
    PrintInfo(nilInterfece)
    PrintInfo(&amp;nilInterfece)

}

func PrintInfo(i interface{}) {
    if i == nil {
        fmt.Println(&quot;--------------------&quot;)
        fmt.Printf(&quot;无效接口值：%v\n&quot;, i)
        return
    }
    t := reflect.TypeOf(i)
    PrintType(t)
}

func PrintType(t reflect.Type) {
    fmt.Println(&quot;--------------------&quot;)
    // ----- 通用方法 -----
    fmt.Println(&quot;String             :&quot;, t.String())     // 类型字符串
    fmt.Println(&quot;Name               :&quot;, t.Name())       // 类型名称
    fmt.Println(&quot;PkgPath            :&quot;, t.PkgPath())    // 所在包名称
    fmt.Println(&quot;Kind               :&quot;, t.Kind())       // 所属分类
    fmt.Println(&quot;Size               :&quot;, t.Size())       // 内存大小
    fmt.Println(&quot;Align              :&quot;, t.Align())      // 字节对齐
    fmt.Println(&quot;FieldAlign         :&quot;, t.FieldAlign()) // 字段对齐
    fmt.Println(&quot;NumMethod          :&quot;, t.NumMethod())  // 方法数量
    if t.NumMethod() &gt; 0 {
        i := 0
        for ; i &lt; t.NumMethod()-1; i++ {
            fmt.Println(&quot;    ┣&quot;, t.Method(i).Name) // 通过索引定位方法
        }
        fmt.Println(&quot;    ┗&quot;, t.Method(i).Name) // 通过索引定位方法
    }
    if sm, ok := t.MethodByName(&quot;String&quot;); ok { // 通过名称定位方法
        fmt.Println(&quot;MethodByName       :&quot;, sm.Index, sm.Name)
    }
    fmt.Println(&quot;Implements(i{})    :&quot;, t.Implements(interfaceType))  // 是否实现了指定接口
    fmt.Println(&quot;ConvertibleTo(int) :&quot;, t.ConvertibleTo(reflectType)) // 是否可转换为指定类型
    fmt.Println(&quot;AssignableTo(int)  :&quot;, t.AssignableTo(reflectType))  // 是否可赋值给指定类型的变量
    fmt.Println(&quot;Comparable         :&quot;, t.Comparable())               // 是否可进行比较操作
    // ----- 特殊类型 -----
    switch t.Kind() {
    // 指针型：
    case reflect.Ptr:
        fmt.Println(&quot;=== 指针型 ===&quot;)
        // 获取指针所指对象
        t = t.Elem()
        fmt.Printf(&quot;转换到指针所指对象 : %v\n&quot;, t.String())
        // 递归处理指针所指对象
        PrintType(t)
        return
    // 自由指针型：
    case reflect.UnsafePointer:
        fmt.Println(&quot;=== 自由指针 ===&quot;)
    // ...
    // 接口型：
    case reflect.Interface:
        fmt.Println(&quot;=== 接口型 ===&quot;)
    // ...
    }
    // ----- 简单类型 -----
    // 数值型：
    if reflect.Int &lt;= t.Kind() &amp;&amp; t.Kind() &lt;= reflect.Complex128 {
        fmt.Println(&quot;=== 数值型 ===&quot;)
        fmt.Println(&quot;Bits               :&quot;, t.Bits()) // 位宽
    }
    // ----- 复杂类型 -----
    switch t.Kind() {
    // 数组型：
    case reflect.Array:
        fmt.Println(&quot;=== 数组型 ===&quot;)
        fmt.Println(&quot;Len                :&quot;, t.Len())  // 数组长度
        fmt.Println(&quot;Elem               :&quot;, t.Elem()) // 数组元素类型
    // 切片型：
    case reflect.Slice:
        fmt.Println(&quot;=== 切片型 ===&quot;)
        fmt.Println(&quot;Elem               :&quot;, t.Elem()) // 切片元素类型
    // 映射型：
    case reflect.Map:
        fmt.Println(&quot;=== 映射型 ===&quot;)
        fmt.Println(&quot;Key                :&quot;, t.Key())  // 映射键
        fmt.Println(&quot;Elem               :&quot;, t.Elem()) // 映射值类型
    // 通道型：
    case reflect.Chan:
        fmt.Println(&quot;=== 通道型 ===&quot;)
        fmt.Println(&quot;ChanDir            :&quot;, t.ChanDir()) // 通道方向
        fmt.Println(&quot;Elem               :&quot;, t.Elem())    // 通道元素类型
    // 结构体：
    case reflect.Struct:
        fmt.Println(&quot;=== 结构体 ===&quot;)
        fmt.Println(&quot;NumField           :&quot;, t.NumField()) // 字段数量
        if t.NumField() &gt; 0 {
            var i, j int
            // 遍历结构体字段
            for i = 0; i &lt; t.NumField()-1; i++ {
                field := t.Field(i) // 获取结构体字段
                fmt.Printf(&quot;    ├ %v\n&quot;, field.Name)
                // 遍历嵌套结构体字段
                if field.Type.Kind() == reflect.Struct &amp;&amp; field.Type.NumField() &gt; 0 {
                    for j = 0; j &lt; field.Type.NumField()-1; j++ {
                        subfield := t.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                        fmt.Printf(&quot;    │    ├ %v\n&quot;, subfield.Name)
                    }
                    subfield := t.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                    fmt.Printf(&quot;    │    └ %%v\n&quot;, subfield.Name)
                }
            }
            field := t.Field(i) // 获取结构体字段
            fmt.Printf(&quot;    └ %v\n&quot;, field.Name)
            // 通过名称查找字段
            if field, ok := t.FieldByName(&quot;ptr&quot;); ok {
                fmt.Println(&quot;FieldByName(ptr)   :&quot;, field.Name)
            }
            // 通过函数查找字段
            if field, ok := t.FieldByNameFunc(func(s string) bool { return len(s) &gt; 3 }); ok {
                fmt.Println(&quot;FieldByNameFunc    :&quot;, field.Name)
            }
        }
    // 函数型：
    case reflect.Func:
        fmt.Println(&quot;=== 函数型 ===&quot;)
        fmt.Println(&quot;IsVariadic         :&quot;, t.IsVariadic()) // 是否具有变长参数
        fmt.Println(&quot;NumIn              :&quot;, t.NumIn())      // 参数数量
        if t.NumIn() &gt; 0 {
            i := 0
            for ; i &lt; t.NumIn()-1; i++ {
                fmt.Println(&quot;    ┣&quot;, t.In(i)) // 获取参数类型
            }
            fmt.Println(&quot;    ┗&quot;, t.In(i)) // 获取参数类型
        }
        fmt.Println(&quot;NumOut             :&quot;, t.NumOut()) // 返回值数量
        if t.NumOut() &gt; 0 {
            i := 0
            for ; i &lt; t.NumOut()-1; i++ {
                fmt.Println(&quot;    ┣&quot;, t.Out(i)) // 获取返回值类型
            }
            fmt.Println(&quot;    ┗&quot;, t.Out(i)) // 获取返回值类型
        }
    }
}
</code></pre><p> </p><h1 id="reflect-value-类型">reflect.Value 类型</h1><p>代码，</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;unsafe&quot;
)

// 嵌套结构体
type ss struct {
    a struct {
        int
        string
    }
    int
    string
    bool
    float64
}

func (s ss) Method1(i int) string  { return &quot;结构体方法1&quot; }
func (s *ss) Method2(i int) string { return &quot;结构体方法2&quot; }

var (
    intValue   = int(0)
    int8Value  = int8(8)
    int16Value = int16(16)
    int32Value = int32(32)
    int64Value = int64(64)

    uIntValue   = uint(0)
    uInt8Value  = uint8(8)
    uInt16Value = uint16(16)
    uInt32Value = uint32(32)
    uInt64Value = uint64(64)

    byteValue    = byte(0)
    runeValue    = rune(0)
    uintptrValue = uintptr(0)

    boolValue   = false
    stringValue = &quot;stringValue&quot;

    float32Value = float32(32)
    float64Value = float64(64)

    complex64Value  = complex64(64)
    complex128Value = complex128(128)

    arrayValue  = [5]string{}           // 数组
    sliceValue  = []byte{0, 0, 0, 0, 0} // 切片
    mapValue    = map[string]int{}      // 映射
    chanValue   = make(chan int, 2)     // 通道
    structValue = ss{ // 结构体
            struct {
            int
            string
        }{10, &quot;子结构体&quot;},
        20,
        &quot;结构体&quot;,
        false,
        64.0,
    }

    func1Value = func(i int) string { // 函数（固定参数）
        return fmt.Sprintf(&quot;固定参数：%v&quot;, i)
    }

    func2Value = func(i ...int) string { // 函数（动态参数）
        return fmt.Sprintf(&quot;动态参数：%v&quot;, i)
    }

    unsafePointer     = unsafe.Pointer(&amp;structValue)    // 通用指针
    reflectType       = reflect.TypeOf(0)               // 反射类型
    reflectValue      = reflect.ValueOf(0)              // 反射值
    reflectArrayValue = reflect.ValueOf([]int{1, 2, 3}) // 切片反射值
    // 反射接口类型
    interfaceType = reflect.TypeOf(new(interface{})).Elem()
)

// 简单类型
var simpleTypes = []interface{}{
    intValue, &amp;intValue,               // int
    int8Value, &amp;int8Value,             // int8
    int16Value, &amp;int16Value,           // int16
    int32Value, &amp;int32Value,           // int32
    int64Value, &amp;int64Value,           // int64
    uIntValue, &amp;uIntValue,             // uint
    uInt8Value, &amp;uInt8Value,           // uint8
    uInt16Value, &amp;uInt16Value,         // uint16
    uInt32Value, &amp;uInt32Value,         // uint32
    uInt64Value, &amp;uInt64Value,         // uint64
    byteValue, &amp;byteValue,             // byte
    runeValue, &amp;runeValue,             // rune
    uintptrValue, &amp;uintptrValue,       // uintptr
    boolValue, &amp;boolValue,             // bool
    stringValue, &amp;stringValue,         // string
    float32Value, &amp;float32Value,       // float32
    float64Value, &amp;float64Value,       // float64
    complex64Value, &amp;complex64Value,   // complex64
    complex128Value, &amp;complex128Value, // complex128
}

// 复杂类型
var complexTypes = []interface{}{
    arrayValue, &amp;arrayValue,                  // 数组
    sliceValue, &amp;sliceValue,                  // 切片
    mapValue, &amp;mapValue,                      // 映射
    chanValue, &amp;chanValue,                    // 通道
    structValue, &amp;structValue,                // 结构体
    func1Value, &amp;func1Value,                  // 定参函数
    func2Value, &amp;func2Value,                  // 动参函数
    structValue.Method1, structValue.Method2, // 方法
    unsafePointer, &amp;unsafePointer,            // 指针
    reflectType, &amp;reflectType,                // 反射类型
    reflectValue, &amp;reflectValue,              // 反射值
    interfaceType, &amp;interfaceType,            // 接口反射类型
}

// 空值
var unsafeP unsafe.Pointer

// 空接口
var nilInterfece interface{}

func main() {
    // 测试简单类型
    for i := 0; i &lt; len(simpleTypes); i++ {
        PrintInfo(simpleTypes[i])
    }
    // 测试复杂类型
    for i := 0; i &lt; len(complexTypes); i++ {
        PrintInfo(complexTypes[i])
    }
    // 测试单个对象
    PrintInfo(&amp;unsafeP)
    PrintInfo(nilInterfece)
    // PrintInfo(&amp;nilInterfece) // 会引发 panic
}

func PrintInfo(i interface{}) {
    if i == nil {
        fmt.Println(&quot;--------------------&quot;)
        fmt.Printf(&quot;无效接口值：%v\n&quot;, i)
        fmt.Println(&quot;--------------------&quot;)
        return
    }
    v := reflect.ValueOf(i)
    PrintValue(v)
}

func PrintValue(v reflect.Value) {
    fmt.Println(&quot;--------------------&quot;)
    // ----- 通用方法 -----
    fmt.Println(&quot;String             :&quot;, v.String())  // 反射值的字符串形式
    fmt.Println(&quot;Type               :&quot;, v.Type())    // 反射值的类型
    fmt.Println(&quot;Kind               :&quot;, v.Kind())    // 反射值的类别
    fmt.Println(&quot;CanAddr            :&quot;, v.CanAddr()) // 是否可以获取地址
    fmt.Println(&quot;CanSet             :&quot;, v.CanSet())  // 是否可以修改
    if v.CanAddr() {
        fmt.Println(&quot;Addr               :&quot;, v.Addr())       // 获取地址
        fmt.Println(&quot;UnsafeAddr         :&quot;, v.UnsafeAddr()) // 获取自由地址
    }
    // 是否可转换为接口对象
    fmt.Println(&quot;CanInterface       :&quot;, v.CanInterface())
    if v.CanInterface() {
        fmt.Println(&quot;Interface          :&quot;, v.Interface()) // 转换为接口对象
    }
    // 获取方法数量
    fmt.Println(&quot;NumMethod          :&quot;, v.NumMethod())
    if v.NumMethod() &gt; 0 {
        // 遍历方法
        i := 0
        for ; i &lt; v.NumMethod()-1; i++ {
            fmt.Printf(&quot;    ┣ %v\n&quot;, v.Method(i).String())
            //          if i &gt;= 4 { // 只列举 5 个
            //              fmt.Println(&quot;    ┗ ...&quot;)
            //              break
            //          }
        }
        fmt.Printf(&quot;    ┗ %v\n&quot;, v.Method(i).String())
        // 通过名称获取方法
        fmt.Println(&quot;MethodByName       :&quot;, v.MethodByName(&quot;String&quot;).String())
    }
    // ----- 可获取指针的类型 -----
    switch v.Kind() {
    case reflect.Slice, reflect.Map, reflect.Chan, reflect.Func,
        reflect.Ptr, reflect.UnsafePointer:
        fmt.Println(&quot;Pointer            :&quot;, v.Pointer())
    }
    // ----- 特殊类型 -----
    switch v.Kind() {
    // 指针：
    case reflect.Ptr:
        fmt.Println(&quot;=== 指针 ===&quot;)
        // 获取指针地址
        if !v.IsNil() {
            // 获取指针所指对象
            v = v.Elem() // 只有指针和接口类型可以使用 Elem()
            fmt.Printf(&quot;转换到指针所指对象 : %v\n&quot;, v.Type())
            // 递归处理指针所指对象
            PrintValue(v)
            return
        }
    // 自由指针：
    case reflect.UnsafePointer:
        fmt.Println(&quot;=== 自由指针 ===&quot;)
        if v.Pointer() == 0 {
            v.SetPointer(unsafePointer)
            fmt.Println(&quot;重新指向新对象     :&quot;, v.Pointer())
        }
        // 将自由指针转换为 *ss 指针（因为定义 unsafePointer 时已经确定了类型）
        s := (*ss)(v.Interface().(unsafe.Pointer))
        // 获取反射值
        v = reflect.ValueOf(s)
        if !v.IsNil() {
            // 获取指针所指对象
            v = v.Elem() // 只有指针和接口类型可以使用 Elem()
            fmt.Printf(&quot;转换到指针所指对象 : %v\n&quot;, v.Type())
            // 递归处理指针所指对象
            PrintValue(v)
            return
        }
    // 接口：
    case reflect.Interface:
        fmt.Println(&quot;=== 接口 ===&quot;)
        // 获取接口数据
        fmt.Println(&quot;InterfaceData      :&quot;, v.InterfaceData())
        // 获取接口所包含的对象
        v = v.Elem() // 只有指针和接口类型可以使用 Elem()
        fmt.Printf(&quot;转换到接口所含对象 : %v\n&quot;, v.Type())
        // 递归处理接口的动态对象
        PrintValue(v)
        return
    }
    // ----- 简单类型 -----
    // 有符号整型：
    if reflect.Int &lt;= v.Kind() &amp;&amp; v.Kind() &lt;= reflect.Int64 {
        fmt.Println(&quot;=== 有符号整型 ===&quot;)
        fmt.Println(&quot;Int                :&quot;, v.Int()) // 获取值
        if v.CanSet() {
            v.SetInt(10)                                 // 设置值
            fmt.Println(&quot;Int                :&quot;, v.Int()) // 获取值
            v.Set(reflect.ValueOf(20).Convert(v.Type())) // 设置值
        }
        fmt.Println(&quot;Int                :&quot;, v.Int())           // 获取值
        fmt.Println(&quot;OverflowInt        :&quot;, v.OverflowInt(10)) // 是否溢出
    }
    // 无符号整型：
    if reflect.Uint &lt;= v.Kind() &amp;&amp; v.Kind() &lt;= reflect.Uint64 {
        fmt.Println(&quot;=== 无符号整型 ===&quot;)
        fmt.Println(&quot;Uint               :&quot;, v.Uint()) // 获取值
        if v.CanSet() {
            v.SetUint(10)                                 // 设置值
            fmt.Println(&quot;Uint               :&quot;, v.Uint()) // 获取值
            v.Set(reflect.ValueOf(20).Convert(v.Type()))  // 设置值
        }
        fmt.Println(&quot;Uint               :&quot;, v.Uint())           // 获取值
        fmt.Println(&quot;OverflowUint       :&quot;, v.OverflowUint(10)) // 是否溢出
    }
    switch v.Kind() {
    // 浮点数：
    case reflect.Float32, reflect.Float64:
        fmt.Println(&quot;=== 浮点数 ===&quot;)
        fmt.Println(&quot;Float              :&quot;, v.Float()) // 获取值
        if v.CanSet() {
            v.SetFloat(10)                                 // 设置值
            fmt.Println(&quot;Float              :&quot;, v.Float()) // 获取值
            v.Set(reflect.ValueOf(20).Convert(v.Type()))   // 设置值
        }
        fmt.Println(&quot;Float              :&quot;, v.Float())           // 获取值
        fmt.Println(&quot;OverflowFloat      :&quot;, v.OverflowFloat(10)) // 是否溢出
    // 复数：
    case reflect.Complex64, reflect.Complex128:
        fmt.Println(&quot;=== 复数 ===&quot;)
        fmt.Println(&quot;Complex            :&quot;, v.Complex()) // 获取值
        if v.CanSet() {
            v.SetComplex(10)                                   // 设置值
            fmt.Println(&quot;Complex            :&quot;, v.Complex())   // 获取值
            v.Set(reflect.ValueOf(20 + 20i).Convert(v.Type())) // 设置值
        }
        fmt.Println(&quot;Complex            :&quot;, v.Complex())           // 获取值
        fmt.Println(&quot;OverflowComplex    :&quot;, v.OverflowComplex(10)) // 是否溢出
    // 布尔型：
    case reflect.Bool:
        fmt.Println(&quot;=== 布尔型 ===&quot;)
        fmt.Println(&quot;Bool               :&quot;, v.Bool()) // 获取值
        if v.CanSet() {
            v.SetBool(true)                               // 设置值
            fmt.Println(&quot;Bool               :&quot;, v.Bool()) // 获取值
            v.Set(reflect.ValueOf(false))                 // 设置值
        }
        fmt.Println(&quot;Bool               :&quot;, v.Bool()) // 获取值
    // 字符串：
    case reflect.String:
        fmt.Println(&quot;=== 字符串 ===&quot;)
        fmt.Println(&quot;String             :&quot;, v.String()) // 获取值
        if v.CanSet() {
            v.SetString(&quot;abc&quot;)                              // 设置值
            fmt.Println(&quot;String             :&quot;, v.String()) // 获取值
            v.Set(reflect.ValueOf(&quot;def&quot;))                   // 设置值
        }
        fmt.Println(&quot;String             :&quot;, v.String()) // 获取值
    // ----- 复杂类型 -----
    // 切片型：
    case reflect.Slice:
        fmt.Println(&quot;=== 切片型 ===&quot;)
        fmt.Println(&quot;Len                :&quot;, v.Len()) // 获取长度
        fmt.Println(&quot;Cap                :&quot;, v.Cap()) // 获取容量
        if v.CanSet() {
            v.SetLen(4) // 不能大于 cap
            v.SetCap(4) // 不能小于 len，只能缩，不能扩
            fmt.Println(&quot;SetLen, SetCap     :&quot;, v.Len(), v.Cap())
            // 重新指定字节内容
            if v.Type().Elem().Kind() == reflect.Uint8 {
                v.SetBytes([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0})
            }
            fmt.Println(&quot;SetByte            :&quot;, []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0})
        }
        // 获取字节内容
        if v.Type().Elem().Kind() == reflect.Uint8 {
            fmt.Println(&quot;Bytes              :&quot;, v.Bytes())
        }
        // 根据索引获取元素
        if v.Len() &gt; 0 {
            for i := 0; i &lt; v.Len(); i++ {
                fmt.Println(&quot;Index              :&quot;, v.Index(i))
            }
        }
        // 获取一个指定范围的切片
        // 参数：起始下标，结束下标
        // 长度 = 结束下标 - 起始下标
        s1 := v.Slice(1, 2)
        fmt.Println(&quot;Slice              :&quot;, s1)
        fmt.Println(&quot;Len                :&quot;, s1.Len()) // 获取长度
        fmt.Println(&quot;Cap                :&quot;, s1.Cap()) // 获取容量
        // 获取一个指定范围和容量的切片
        // 参数：起始下标，结束下标，容量下标
        // 长度 = 结束下标 - 起始下标
        // 容量 = 容量下标 - 起始下标
        s2 := v.Slice3(1, 2, 4)
        fmt.Println(&quot;Slice              :&quot;, s2)
        fmt.Println(&quot;Len                :&quot;, s2.Len()) // 获取长度
        fmt.Println(&quot;Cap                :&quot;, s2.Cap()) // 获取容量
    // 映射型：
    case reflect.Map:
        fmt.Println(&quot;=== 映射型 ===&quot;)
        // 设置键值，不需要检测 CanSet
        v.SetMapIndex(reflect.ValueOf(&quot;a&quot;), reflect.ValueOf(1))
        v.SetMapIndex(reflect.ValueOf(&quot;b&quot;), reflect.ValueOf(2))
        v.SetMapIndex(reflect.ValueOf(&quot;c&quot;), reflect.ValueOf(3))
        // 获取键列表
        fmt.Println(&quot;MapKeys            :&quot;, v.MapKeys())
        for _, idx := range v.MapKeys() {
            // 根据键获取值
            fmt.Println(&quot;MapIndex           :&quot;, v.MapIndex(idx))
        }
    // 结构体：
    case reflect.Struct:
        fmt.Println(&quot;=== 结构体 ===&quot;)
        // 获取字段个数
        fmt.Println(&quot;NumField           :&quot;, v.NumField())
        if v.NumField() &gt; 0 {
            var i, j int
            // 遍历结构体字段
            for i = 0; i &lt; v.NumField()-1; i++ {
                field := v.Field(i) // 获取结构体字段
                fmt.Printf(&quot;    ├ %-8v %v\n&quot;, field.Type(), field.String())
                // 遍历嵌套结构体字段
                if field.Kind() == reflect.Struct &amp;&amp; field.NumField() &gt; 0 {
                    for j = 0; j &lt; field.NumField()-1; j++ {
                        subfield := v.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                        fmt.Printf(&quot;    │    ├ %-8v %v\n&quot;, subfield.Type(), subfield.String())
                        // if i &gt;= 4 { // 只列举 5 个
                        //  fmt.Println(&quot;        ┗ ...&quot;)
                        //  break
                        // }
                    }
                    subfield := v.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                    fmt.Printf(&quot;    │    └ %-8v %v\n&quot;, subfield.Type(), subfield.String())
                }
                // if i &gt;= 4 { // 只列举 5 个
                //  fmt.Println(&quot;    ┗ ...&quot;)
                //  break
                // }
            }
            field := v.Field(i) // 获取结构体字段
            fmt.Printf(&quot;    └ %-8v %v\n&quot;, field.Type(), field.String())
            // 通过名称查找字段
            if v := v.FieldByName(&quot;ptr&quot;); v.IsValid() {
                fmt.Println(&quot;FieldByName(ptr)   :&quot;, v.Type().Name())
            }
            // 通过函数查找字段
            v := v.FieldByNameFunc(func(s string) bool { return len(s) &gt; 3 })
            if v.IsValid() {
                fmt.Println(&quot;FieldByNameFunc    :&quot;, v.Type().Name())
            }
        }
    // 通道型：
    case reflect.Chan:
        fmt.Println(&quot;=== 通道型 ===&quot;)
        // 发送数据（会阻塞）
        v.Send(reflectValue)
        // 尝试发送数据（不会阻塞）
        fmt.Println(&quot;TrySend            :&quot;, v.TrySend(reflectValue))
        // 接收数据（会阻塞）
        if x, ok := v.Recv(); ok {
            fmt.Println(&quot;Recv               :&quot;, x) //
        }
        // 尝试接收数据（不会阻塞）
        if x, ok := v.TryRecv(); ok {
            fmt.Println(&quot;TryRecv            :&quot;, x) //
        }
    // 因为要执行两次，通道和通道指针各执行一次，关闭后第二次就无法执行了。
    // v.Close()
    // 函数型：
    case reflect.Func:
        fmt.Println(&quot;=== 函数型 ===&quot;)
        // 判断函数是否具有变长参数
        if v.Type().IsVariadic() {
            // 与可变参数对应的实参必须是切片类型的反射值（reflectArrayValue）。
            fmt.Println(&quot;CallSlice          :&quot;, v.CallSlice([]reflect.Value{reflectArrayValue})) //
            // 也可以用 v.Call 调用变长参数的函数，只需传入 reflectValue 即可。
        } else {
            // 根据函数定义的参数数量，传入相应数量的反射值（reflectValue）。
            fmt.Println(&quot;Call               :&quot;, v.Call([]reflect.Value{reflectValue})) //
        }
    }
}
</code></pre><p>====END====</p></div><div style="height:130px"><div class="post-copyright" style="float:left"><p class="copyright-item"><span class="item-title">文章作者</span> <span class="item-content">虞双齐</span></p><p class="copyright-item"><span class="item-title">上次更新</span> <span class="item-content">2017-02-24</span></p><p class="copyright-item"><span class="item-title">许可协议</span> <span class="item-content"><a target="_blank" rel="license noopener external nofollow" href="https://creativecommons.org/licenses/by/4.0/deed.zh">署名 4.0 国际</a></span></p></div><div class="post-copyright" style="float:right"><a href="https://info.flagcounter.com/8B1z" target="_blank" rel="noopener external nofollow"><img src="https://s05.flagcounter.com/countxl/8B1z/bg_FFFFFF/txt_000000/border_CCCCCC/columns_4/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a></div></div><div class="post-reward"><input type="checkbox" name="reward" id="reward" hidden> <label class="reward-button" for="reward">赞赏支持</label><div class="qr-code"><label class="qr-code-image" for="reward"><img class="image" src="/img/donateMe_wechat.png"> <span>微信打赏</span></label></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/golang.html">golang</a></div><nav class="post-nav"><a class="prev" href="/blog/2017/golangxue-xi-zhai-lu-si-bao.html"><i class="iconfont icon-left"></i> <span class="prev-text nav-default">Golang学习摘录四:包</span> <span class="prev-text nav-mobile">上一篇</span> </a><a class="next" href="/blog/2017/ming-ling--go-build.html"><span class="next-text nav-default">Gobuild命令说明</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav></footer><div class="disqus-button" id="load_disqus" onclick="load_disqus()">显示 Disqus 评论</div><div id="disqus_thread"></div><script type="text/javascript">function load_disqus() {
        
        
        if (window.location.hostname === 'localhost') return;

        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'yushuangqi';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

        $('#load_disqus').remove();
    };</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div></div></main><footer id="footer" class="footer"><div class="social-links"><a href="mailto:ysqi@yushuangqi.com" rel="me" class="iconfont icon-email" title="email"></a> <a href="http://github.com/ysqi" rel="me" class="iconfont icon-github" title="github"></a> <a href="https://weibo.com/234665601" rel="me" class="iconfont icon-weibo" title="weibo"></a> <a href="https://www.zhihu.com/people/_ysqi/" rel="me" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://yushuangqi.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a></div><div class="copyright"><span class="power-by">Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a> </span><span class="division">|</span> <span class="theme-info">Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a> </span><span class="copyright-year">&copy; 2014 - 2021 <span class="heart"><i class="iconfont icon-heart"></i> </span><span class="author">虞双齐 | <a href="https://beian.miit.gov.cn/">粤ICP备14032560号</a></span></span></div></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script><script id="baidu_analytics">var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>